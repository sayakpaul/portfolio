[
  {
    "objectID": "pages/research.html",
    "href": "pages/research.html",
    "title": "Research",
    "section": "",
    "text": "I am interested in the area of representation learning. More recently, I have developed an interest in diffusion models (subjects include alignment, test-time scaling, controlled generation).\nPlease refer to my Google Scholar profile for details on the publications I have been a part of.\n\nConference tutorials\n\nPractical Adversarial Robustness in Deep Learning: Problems and Solutions (CVPR‚Äô21)\nFoundational Robustness of Foundation Models (NeurIPS‚Äô22)\nAll Things ViTs: Understanding and Interpreting Attention in Vision (CVPR‚Äô23)\n\n\n\nInvited talks, demos, etc.\n\nSoTA Diffusion Models with üß® diffusers (slides and recording)\n\nIBM Research (October 17, 2023)\nThe Dyson Robotics Lab, Imperial College London\nDepartment of Statistics, University of Oxford\n\nüß® diffusers for research at VAL, Indian Institute of Science (IISc), June 12, 2023. Slides are here.\nControlling Text-to-Image Diffusion Models: Assorted Approaches\n\nBigMAC ICCV Workshop in 2023 (slides, recording)\nUCL in June 2024\nTexas A&M University in September 2024 (slides)\nUC Berkeley in October 2024 (slides, recording)\nICDMAI‚Äô25 (Slides)\n\nDemo of üß® diffusers at ICCV 2023 (Tweet).\nA talk on diffusion models, ETH Zurich (May 06, 2024). Slides are here.\nTransformers in Diffusion Models for Image Generation and Beyond, CS25 v5, Stanford (May 27, 2025) (slides and recording).\n\nFor regular talks, refer here.\n\n\nTeaching assistance\nServed as a TA for Full Stack Deep Learning‚Äôs 2022 cohort.\n\n\nReviewing\n\nConferences: NeurIPS‚Äô25, ICCV‚Äô25, ICML‚Äô25, CVPR‚Äô25, ICLR‚Äô25, NeurIPS‚Äô24, AAAI‚Äô23, ICASSP‚Äô21 (sub-reviewer).\nWorkshops: UDL workshop (ICML‚Äô21).\nJournals: TMLR, Artificial Intelligence (Elsevier), IEEE Access.\n\n\n\nMisc\n\nReleased a dataset for large-scale multi-label text classification (joint work with Soumik Rakshit).\nExploration on instruction-tuning Stable Diffusion."
  },
  {
    "objectID": "pages/authoring.html",
    "href": "pages/authoring.html",
    "title": "Authoring",
    "section": "",
    "text": "Authored the following liveProjects with Manning:\nBelow are the blogs, articles, and tutorials I have written on Data Science, Machine Learning, and more. I am fortunate enough to collaborate with amazing folks from all around the globe. I am grateful to the GDE Program (ML Developer Programs team) that provides me with Google Cloud Platform credits which I use to run various experiments for my own curiosity and for blog posts."
  },
  {
    "objectID": "pages/authoring.html#footnotes",
    "href": "pages/authoring.html#footnotes",
    "title": "Authoring",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é\nThis article got featured in ‚ÄúPython Top 10 Articles for the Past Month (v.Oct 2018)‚Äù and secured a rank of 4.‚Ü©Ô∏é\nThis article got featured in ‚ÄúMachine Learning Top 10 Articles for the Past Month (v.Nov 2018)‚Äù and secured a rank of 9.‚Ü©Ô∏é\nThis article got featured in ‚ÄúPython Top 10 Articles for the Past Month (v.Dec 2018)‚Äù and secured a rank of 10.‚Ü©Ô∏é\nFeatured in Sebastian Ruder‚Äôs monthly newsletter.‚Ü©Ô∏é\nThis one ranked eighth at a blogging competition.‚Ü©Ô∏é\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é\nIn collaboration with the Neural Structured Learning team at Google.‚Ü©Ô∏é\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é\nThis one won the ML GDE Dev Challenge.‚Ü©Ô∏é\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é\n#TFCommunitySpotlight awarded.‚Ü©Ô∏é"
  },
  {
    "objectID": "pages/xyz.html",
    "href": "pages/xyz.html",
    "title": "XYZ",
    "section": "",
    "text": "On this page, I have listed some things that I do/used to do in the pursuit of ‚Äúhappyness‚Äù.\n\nMisc\n\nTaught under-privileged children and managed operations for a TCS-CSR initiative called H20 (Helping Hand Organization) (2017)\nModerator of the Artificial Intelligence channel of Campus Commune (Jan, 2018 - August, 2018)\nBook reviewer for Manning Publications Co (2019 - 2022)\nCo-organizer of GDG Kolkata (2019 - 2021)\nOrganizer of TensorFlow User Group Kolkata (2020 - 2021)\n\n\n\nMentorship\n\nLaunchpad Women Entrepreneurs (2019)\nExplore ML Academy, Hyderabad (2019)\nAI Hack Tunisia (2019)\nClass III (2019) of Launchpad Accelerator India (Tweet by GoogleDevsIN)\nGoogle Code-in for TensorFlow through December, 2019 - January 2020 (Certificate)\nBuild For Digital India Bootcamps through January 2020 - February 2020 (Tweet by GoogleDevsIN)\nExplore ML Bootcamp, Hyderabad (2020) (Tweet by GoogleDevsIN)\nGoogle for Startups MENA Accelerator 2020 (this was formerly known as Launchpad)\nGoogle for Startups India Accelerator 2020, 2021\nMentored for TensorFlow at Google Summer of Code 2021 (GSoC). Students: Aditya Kane and Vasudev Gupta. Here‚Äôs a related blog post from TensorFlow.\nDeep Learning Indaba. Various university students from Africa since the mentorship program is Africa-focused (2021- 2022).\nMentored for TensorFlow at GSoC 2022. Students: Aditya Kane, Sayan Nath, and Mohammad Shoaib. My mentorship certificate is here.\nGoogle for Startups India Women Founders Accelerator (2022).\nMentored at KaggleX BIPOC 2023. Here is my certificate.\nMentored Yatharth Gupta and Vishnu V. Jaddipal during the development of SSD-1B.\n\nApart from the occasions mentioned above, I have mentored individual students, students belonging to Google Developer Student Clubs, etc. But I don‚Äôt have any recorded documents for these. I enjoy sharing my learnings with those in need and, in turn, learning from them.\n\n\nAwards and recognition\n\nRecipient of the Google Open Source Peer Bonus Award (2020, 2021, and 2022). Here‚Äôs a related blog post (from the official Google Open Source Blog) jotting down the experiences that led to this honor (2020).\nLed our team at PyImageSearch to Top 10 at this CVPR 2021 competition.\nFinished 2nd (with Siddha Ganju) at this competition (2021) organized by the NASA Impact team (Certificate).\nReceived (sometimes jointly) the #TFCommunitySpotlight award multiple times for projects with varying use-cases, tooling, and motivation. Details in the following tweets by TensorFlow: Tweet 1, Tweet 2, Tweet 3, Tweet 4, Tweet 5, Tweet 6, Tweet 7, Tweet 8, Tweet 9, Tweet 10, and Tweet 11.\nRanked 8 at Applied Roots Blogathon 2021.\nRecipient of the Intel Top Innovator Award (2019).\nBecame a Google Cloud Innovator (Champion tier).\nAwarded as the Top Regional Contributor from India for TensorFlow, 2021. Blog post and Tweet from TensorFlow.\nReceived NeurIPS 2021 AI4Science Workshop Travel Grant for this work.\nReceived the Google OSS Expert Prize (February, 2022) with Soumik Rakshit for this work.\nReceived the Google OSS Expert Prize (March, 2022) with Aritra Roy Gosthipaty for this work.\nReceived the Google OSS Expert Prize (April, 2022) for this work.\nReceived the Google OSS Expert Prize (May, 2022) with Aritra Roy Gosthipaty for this work.\nAwarded as a Top Contributor to Papers With Code. Award link is here.\nAccepted to the Oxford ML Summer School (2022) for the healthcare track. Certificate link is here.\nReceived the Kaggle ML Research Spotlight Prize (September, 2022) for this work.\nReceived the Kaggle ML Research Spotlight Prize (November, 2022) for this work.\nSecured 2nd place in the first ever Keras Community Prize Competition organized by Google for this project with Chansung Park.\nGot financial aid for EuroPython‚Äô24.\nGot a scholarship for Open-Source Summit Japan 2024.\nBeacon Award 2024 by Google for Developers.\n\n\n\nNon-tech\n\nI love listening to all genres of music. A guitar player myself. Have played in a band Behest from 2013 to 2017.\nI love watching TV serials also (Narcos, Suits, Downton Abbey, Breaking Bad, Ozark being all-time favorites)."
  },
  {
    "objectID": "pages/about.html",
    "href": "pages/about.html",
    "title": "About Me",
    "section": "",
    "text": "I work on diffusion models at Hugging Face. My day-to-day includes contributing features to üß® diffusers, maintaining it, training and babysitting diffusion models, and sometimes muddying up the social media with emojis üòÇ. I am fortunate to have worked in different areas of machine learning (such as training and deploying BERT-sized language models1, scalable MLOps architectures2, model robustness3, etc.). For more details on my work experience, check out my GitHub and LinkedIn.\nI run into ideas from time to time that need further looking around, experimentation, etc., which I like to refer to as ‚Äúapplied research‚Äù. You can get an idea of what I mean by that from this page. I enjoy implementing research ideas, sometimes incorporating them into practical applications, and communicating my implementation details through articles. I advocate for readable and self-contained code. I primarily use Python for programming.\nI have a flair for open-source initiatives. In particular, I have contributed to Keras, KerasCV, ü§ó Transformers, TensorFlow Hub, Keras Examples, TensorFlow Addons, and Neural Structured Learning. From time to time, I also contribute to other Hugging Face libraries, such as Accelerate, Optimum Quanto, and PEFT. Thanks to my job, I get to do open-source full-time now! Off the work, I like writing technical articles, working on applied ML ideas, and speaking at conferences.\nFor my community contributions and innovative projects, the Intel Software Innovator Program recognized me as one of their top innovators in 2019. For my open-source contributions, I received the Google Open Source Peer Bonus Award in 2020, 2021, and 2022, and TensorFlow Top Contributor Award in 2021. A detailed account of the awards and recognitions is available here."
  },
  {
    "objectID": "pages/about.html#footnotes",
    "href": "pages/about.html#footnotes",
    "title": "About Me",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nBuilding an Efficient Machine Learning API (joint work with Nilabhra Roy Chowdhury)‚Ü©Ô∏é\nEnd-to-End Pipeline for Segmentation with TFX, Google Cloud, and Hugging Face (joint work with Chansung Park)‚Ü©Ô∏é\nVision Transformers are Robust Learners‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/2020-04-13-embedding-image-preprocessing-functions.html",
    "href": "posts/2020-04-13-embedding-image-preprocessing-functions.html",
    "title": "Embedding an image preprocessing function in a tf.keras model",
    "section": "",
    "text": "In this tutorial, we are going to see how to embed a simple image preprocessing function within a trained model (tf.keras) while exporting it for serving. This is a useful feature to have because it can help us reduce a lot of boilerplate code needed while using any model for serving purposes. With this capability, you get a lot more flexibility and modularity to your model.\nTo keep things simple we will be using the FashionMNIST dataset. Note that these techniques can easily be applied to more complex models as well (with some limitation).\n# Load data\n(x_train, y_train), (x_test, y_test) = tf.keras.datasets.fashion_mnist.load_data()\n# Class labels (don't change the order)\nCLASSES = [\"T-shirt/top\", \"Trouser\", \"Pullover\", \"Dress\", \"Coat\",\n               \"Sandal\", \"Shirt\", \"Sneaker\", \"Bag\", \"Ankle boot\"]\n# Show a few examples from the train set\nplt.figure(figsize=(10,10))\nfor i in range(25):\n    plt.subplot(5,5,i+1)\n    plt.xticks([])\n    plt.yticks([])\n    plt.grid(True)\n    plt.imshow(x_train[i], cmap=plt.cm.binary)\n    plt.xlabel(CLASSES[y_train[i]])\nplt.show()"
  },
  {
    "objectID": "posts/2020-04-13-embedding-image-preprocessing-functions.html#model-building-and-training",
    "href": "posts/2020-04-13-embedding-image-preprocessing-functions.html#model-building-and-training",
    "title": "Embedding an image preprocessing function in a tf.keras model",
    "section": "Model building and training",
    "text": "Model building and training\nWe are good to proceed towards building and training a neural network. We will first define a simple preprocessing function to scale the pixel values and then we will embed it into the model using a Lambda layer. You can replace this anything fancy you would want.\nWe will use a shallow network architecture so that we can train it quickly.\n\n# Define the preprocessing function\n# We will embed it in the model later\ndef preprocess_image(image_pixels):\n    img = image_pixels / 255\n    return img\n\n# A humble model\ndef get_training_model():\n    # Construct the model using the Functional API\n    input_layer = tf.keras.layers.Input(shape=(28, 28), name=\"input_layer\")\n    preproc_layer = tf.keras.layers.Lambda(preprocess_image, name=\"lambda_layer\")(input_layer) # Preprocessing function\n    flatten = tf.keras.layers.Flatten()(preproc_layer)\n    dense_1 = tf.keras.layers.Dense(128, activation=\"relu\")(flatten)\n    dropout = tf.keras.layers.Dropout(0.2)(dense_1)\n    outputs = tf.keras.layers.Dense(len(CLASSES), activation=\"softmax\")(dropout)\n\n    # Create the model\n    model = tf.keras.models.Model(input_layer, outputs)\n\n    # Compile the model and return it\n    model.compile(optimizer='adam',\n                loss='sparse_categorical_crossentropy',\n                metrics=['accuracy'])\n        \n    return model\n\n\n# Topology of the model\ntf.keras.utils.plot_model(get_training_model(), show_shapes=True)\n\n\n\n\n\n\n\n\nThe Lambda layer is our preprocessing layer.\n\n# Train the model for 10 epochs\napparel_model = get_training_model()\nhistory = apparel_model.fit(x_train, y_train, \n    validation_data=(x_test, y_test), \n    epochs=10, \n    batch_size=128)\n\nEpoch 1/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.6004 - accuracy: 0.7937 - val_loss: 0.4682 - val_accuracy: 0.8347\nEpoch 2/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.4246 - accuracy: 0.8495 - val_loss: 0.4089 - val_accuracy: 0.8521\nEpoch 3/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3795 - accuracy: 0.8642 - val_loss: 0.3928 - val_accuracy: 0.8564\nEpoch 4/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3576 - accuracy: 0.8711 - val_loss: 0.3632 - val_accuracy: 0.8687\nEpoch 5/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3407 - accuracy: 0.8762 - val_loss: 0.3593 - val_accuracy: 0.8688\nEpoch 6/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3294 - accuracy: 0.8788 - val_loss: 0.3532 - val_accuracy: 0.8721\nEpoch 7/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3165 - accuracy: 0.8846 - val_loss: 0.3609 - val_accuracy: 0.8685\nEpoch 8/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3084 - accuracy: 0.8859 - val_loss: 0.3503 - val_accuracy: 0.8701\nEpoch 9/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.2982 - accuracy: 0.8915 - val_loss: 0.3560 - val_accuracy: 0.8713\nEpoch 10/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.2886 - accuracy: 0.8929 - val_loss: 0.3381 - val_accuracy: 0.8776\n\n\nNow that we have a trained model, we can go ahead and export it and then we will see how to use it on new images for inference."
  },
  {
    "objectID": "posts/2020-04-13-embedding-image-preprocessing-functions.html#sample-test-image-and-model-export",
    "href": "posts/2020-04-13-embedding-image-preprocessing-functions.html#sample-test-image-and-model-export",
    "title": "Embedding an image preprocessing function in a tf.keras model",
    "section": "Sample test image and model export",
    "text": "Sample test image and model export\nWe are getting close. Now that we have a trained model here are the things we would do from here: - Serialize a randomly selected image from the test set.\n- Export the model and parse model predictions.\nLet‚Äôs go.\n\nStep 1: Serializing a randomly selected image from the test set\n\n# Select a random image from the test set for serialization\nsampe_test_img_id = np.random.choice(x_test.shape[0], 1)\nsampe_test_img = x_test[sampe_test_img_id].squeeze() # Remove the batch dimension\nsampe_test_img = (sampe_test_img * 255).astype(\"int32\") # Scale back to integer\n\n# Verify image label and shape\nprint(\"Image class: \",CLASSES[y_test[int(sampe_test_img_id)]])\nprint(sampe_test_img.shape)\n\nImage class:  Ankle boot\n(28, 28)\n\n\n\n# Serialize the image\ncv2.imwrite(\"sample_image.png\", sampe_test_img)\n\nNote that while writing a grayscale image, OpenCV adds the channel dimension of 3 to it. We will need to handle carefully.\n\n# Make sure the serialized image is good to go\nplt.imshow(plt.imread(\"sample_image.png\"), cmap=plt.cm.binary)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nStep 2: Model exporting and parsing predictions\nLet‚Äôs first serialize our model and load it.\n\n# Serialize the model and load it\napparel_model.save(\"apparel_model.h5\")\nrestored_model = tf.keras.models.load_model(\"apparel_model.h5\")\n\nWARNING:tensorflow:Error in loading the saved optimizer state. As a result, your model is starting with a freshly initialized optimizer.\n\n\nThis warning is not desirable. When the optimizer is loaded with a fresh state, the model predictions can be erroneous. So, to resolve this problem we will only be serializing the weights of the model with the save_weights() function. There can be other nuances like this when you work with Lambda layers and you can check this article out to know about them.\n\napparel_model.save_weights(\"apparel_model.h5\")\n\nWe will now initialize a dummy model with the same architecture as the one we trained and we will then load the weights of our trained model into it.\n\nrestored_model = get_training_model()\nrestored_model.load_weights(\"apparel_model.h5\")\n\nNow we should be good to go with the predictions part. First, let‚Äôs load the image we serialized in step 1. As mentioned before, OpenCV adds 3-channels to grayscale images while saving them. We can take care of this issue with cv2.cvtColor(image_pixels, cv2.COLOR_BGR2GRAY).\n\n# Load the image\nimage_pixels = cv2.imread(\"sample_image.png\")\nimage_pixels = cv2.cvtColor(image_pixels, cv2.COLOR_BGR2GRAY)\n\n# Preview the image\nplt.imshow(image_pixels, cmap=plt.cm.binary)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Run inference and parse the prediction\nclass_probabilities = restored_model.predict(np.expand_dims(image_pixels, 0))[0]\nprint(\"Predicted \",CLASSES[np.argmax(class_probabilities)])\n\nPredicted  Ankle boot\n\n\nWe can see that it is working as expected.\n\n# Load and *preprocess* data\n(x_train, y_train), (x_test, y_test) = tf.keras.datasets.fashion_mnist.load_data()\nx_train = x_train / 255\nx_test = x_test / 255"
  },
  {
    "objectID": "posts/2020-04-13-embedding-image-preprocessing-functions.html#taking-it-a-step-further-with-concrete-functions-and-savedmodel",
    "href": "posts/2020-04-13-embedding-image-preprocessing-functions.html#taking-it-a-step-further-with-concrete-functions-and-savedmodel",
    "title": "Embedding an image preprocessing function in a tf.keras model",
    "section": "Taking it a step further with concrete functions and SavedModel",
    "text": "Taking it a step further with concrete functions and SavedModel\nThe SavedModel format is the standard serialization format in TensorFlow 2.x since it communicates very well with the entire TensorFlow ecosystem. Be it GCP AI Platform, be it tf.keras, be it TFLite, etc,, SavedModel format unifies the entire ecosystem. For serializing custom models (developed using subclassing) SavedModel would be needed as well.\nIn this section, let‚Äôs see how can we do the same i.e.¬†embed a preprocessing function inside a model so that it can be serialized in the SavedModel format.\n\nStep 1: Create a sequential model without any preprocessing layer\n\ndef get_training_model_v2():\n    # Construct the model using the Functional API\n    input_layer = tf.keras.layers.Input(shape=(28, 28), name=\"input_layer\")\n    flatten = tf.keras.layers.Flatten()(input_layer)\n    dense_1 = tf.keras.layers.Dense(128, activation=\"relu\")(flatten)\n    dropout = tf.keras.layers.Dropout(0.2)(dense_1)\n    outputs = tf.keras.layers.Dense(len(CLASSES), activation=\"softmax\")(dropout)\n\n    # Create the model\n    model = tf.keras.models.Model(input_layer, outputs)\n\n    # Compile the model and return it\n    model.compile(optimizer=\"adam\",\n                loss=\"sparse_categorical_crossentropy\",\n                metrics=[\"accuracy\"])\n        \n    return model\n\n\n\nStep 2: Train it!\n\n# Train the model for 10 epochs\napparel_model_v2 = get_training_model_v2()\nhistory = apparel_model_v2.fit(x_train, y_train, \n    validation_data=(x_test, y_test), \n    epochs=10, \n    batch_size=128)\n\nEpoch 1/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.5995 - accuracy: 0.7914 - val_loss: 0.4549 - val_accuracy: 0.8347\nEpoch 2/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.4200 - accuracy: 0.8501 - val_loss: 0.4094 - val_accuracy: 0.8520\nEpoch 3/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3823 - accuracy: 0.8616 - val_loss: 0.3831 - val_accuracy: 0.8635\nEpoch 4/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3575 - accuracy: 0.8713 - val_loss: 0.3896 - val_accuracy: 0.8563\nEpoch 5/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3405 - accuracy: 0.8758 - val_loss: 0.3569 - val_accuracy: 0.8720\nEpoch 6/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3249 - accuracy: 0.8813 - val_loss: 0.3490 - val_accuracy: 0.8733\nEpoch 7/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3176 - accuracy: 0.8840 - val_loss: 0.3480 - val_accuracy: 0.8735\nEpoch 8/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.3055 - accuracy: 0.8878 - val_loss: 0.3355 - val_accuracy: 0.8809\nEpoch 9/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.2971 - accuracy: 0.8914 - val_loss: 0.3331 - val_accuracy: 0.8792\nEpoch 10/10\n469/469 [==============================] - 2s 4ms/step - loss: 0.2905 - accuracy: 0.8920 - val_loss: 0.3344 - val_accuracy: 0.8808\n\n\n\n\nStep 3: SavedModel plunge\nOkay! Now we are ready to the crux of the section. We will first create a custom model class (inherited from tf.keras.Model) and it will contain two things: - A model that is loaded with the weights of a trained model - A serving function that will contain the preprocessing function along with the necessary signature.\n\n# A custom class for serving\nclass ExportModel(tf.keras.Model):\n    def __init__(self, model):\n        super().__init__(self)\n        self.model = model\n\n    @tf.function(input_signature=[tf.TensorSpec([None, 28, 28], dtype=tf.uint8)])\n    def my_serve(self, images):\n        images = tf.cast(images, tf.float32) / 255        # pre-processing\n        probabilities = self.model(images)                # prediction from model\n        class_index = tf.argmax(probabilities, axis=-1)   # post-processing\n        return {\"class_index\": class_index}\n\nmy_serve is our serving function. You can see that is decorated with tf.function and the reason behind doing so is it allows us to embed an arbitrary function in a model‚Äôs graph which can later be exported using the SavedModel format.\nWe can also see - input_signature=[tf.TensorSpec([None, 28, 28], dtype=tf.uint8)]. This is needed in order to indicate which part of the model‚Äôs graph would be needed while serving. By specifying tf.TensorSpec([None, 28, 28], we instruct the function that the inputs should respect this shape - [None, 28, 28] and the dtype argument is self-explanatory.\nWe will get to why the return type of the function is done in such a way - {\"class_index\": class_index} in a moment.\nIf you are interested to know more using SavedModel and different serialization options that come with it, be sure to check this tutorial out.\n\n\nStep 4: Instantiate a dummy model and set its weights\n\n# Set the weights of this dummy model to the weights of the model we trained\nrestored_model = get_training_model_v2()\nrestored_model.set_weights(apparel_model_v2.get_weights()) \n\n\n\nStep 5: Export the model and run inference\nNow, to serialize the model in the SavedModel format we will make use of tf.saved_model.save. It can automatically determine which input signature to use for serving for most of the models if the details are available. However, in our case, it won‚Äôt be able to do so. So, we will need to explicitly indicate which function to use as the signature while serving.\n\nexport_path = \"/content/saved_model/1/\"\ntf.keras.backend.set_learning_phase(0) # Make sure no weight update happens\nserving_model = ExportModel(restored_model) # Instantiate a model with the preprocessing function\ntf.saved_model.save(serving_model, export_path, signatures={'serving_default': serving_model.my_serve})\n\nWARNING:tensorflow:Skipping full serialization of Keras layer &lt;__main__.ExportModel object at 0x7f4096b7b358&gt;, because it is not built.\nWARNING:tensorflow:From /usr/local/lib/python3.6/dist-packages/tensorflow/python/ops/resource_variable_ops.py:1817: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version.\nInstructions for updating:\nIf using Keras pass *_constraint arguments to layers.\nINFO:tensorflow:Assets written to: /content/saved_model/1/assets\n\n\nBy specifying 'serving_default': serving_model.my_serve we instructed tf.saved_model.save about which signature to use for serving. Now if we inspect what all were saved, things should seem consistent. For this we are going to use the saved_model_cli command-line interpreter.\n\n!saved_model_cli show --dir /content/saved_model/1 --tag_set serve --signature_def serving_default\n\nThe given SavedModel SignatureDef contains the following input(s):\n  inputs['images'] tensor_info:\n      dtype: DT_UINT8\n      shape: (-1, 28, 28)\n      name: serving_default_images:0\nThe given SavedModel SignatureDef contains the following output(s):\n  outputs['class_index'] tensor_info:\n      dtype: DT_INT64\n      shape: (-1)\n      name: StatefulPartitionedCall:0\nMethod name is: tensorflow/serving/predict\n\n\nSo, we can see that the configuration that is expected from the inputs and the outputs of the serialized model is consistent with what we had instructed. We returned the outputs in form a dictionary (namely class_index) in my_serve and we can see that as well.\nWe can also do the inspection in Pythonic ways.\n\nloaded = tf.saved_model.load(\"/content/saved_model/1/\")\nprint(list(loaded.signatures.keys())) # This signature will be used while serving\n\n['serving_default']\n\n\n\n# Output configuration\ninfer = loaded.signatures[\"serving_default\"]\nprint(infer.structured_outputs)\n\n{'class_index': TensorSpec(shape=(None,), dtype=tf.int64, name='class_index')}\n\n\nLet‚Äôs finally run the inference!\n\n# Load the sample image\nimage_pixels = cv2.imread(\"sample_image.png\")\nimage_pixels = cv2.cvtColor(image_pixels, cv2.COLOR_BGR2GRAY)\n\n\n# Run inference\nCLASSES[infer(tf.constant(image_pixels))[\"class_index\"].numpy()[0]]\n\n'Ankle boot'\n\n\nWe can see that the prediction is correct in this case as well. So, when we ran infer = loaded.signatures[\"serving_default\"] we essentially loaded a concrete function i.e.¬†we loaded my_serve. Remember we assigned the value of serving_default in the beginning of this section?\nWith infer(tf.constant(image_pixels)) we are simply running our input image through the concrete function and we are parsing the output from the dictionary (class_index being the key) it returns ."
  },
  {
    "objectID": "posts/2020-04-13-embedding-image-preprocessing-functions.html#references",
    "href": "posts/2020-04-13-embedding-image-preprocessing-functions.html#references",
    "title": "Embedding an image preprocessing function in a tf.keras model",
    "section": "References",
    "text": "References\n\nMNIST on TPU (Tensor Processing Unit) or GPU using tf.Keras and tf.data.Dataset\nUsing the SavedModel format"
  },
  {
    "objectID": "posts/convnext-tfhub.html",
    "href": "posts/convnext-tfhub.html",
    "title": "Publishing ConvNeXt Models on TensorFlow Hub",
    "section": "",
    "text": "I recently added 15 different variants of the ConvNeXt architecture to TensorFlow Hub (TF-Hub). This post is a reflection of what had to be done to get to that point. First, we‚Äôll discuss the implementation of ConvNeXt in Keras and how the original pre-trained parameters were ported into these models. We‚Äôll then talk about TF-Hub‚Äôs ConvNeXt collection and what it offers.\nI hope this post is useful for anyone willing to contribute models to TF-Hub as doing it the right way can be a good amount of work.\n\nAbout ConvNeXt\nConvNeXt models were proposed by Liu et al.¬†in A ConvNet for the 2020s. ConvNeXt models are composed of standard layers such as depthwise convolutions, layer normalization, etc., and use standard network topologies. They don‚Äôt use self-attention or any hybrid approaches, unlike the recent architectures such as Vision Transformers, CoAtNet, etc. The authors start with a base architecture and gradually refine it to match some of the design choices of Swin Transformers. In the process, they developed a family of models named ConvNeXt achieving performance on the ImageNet-1k dataset with efficiency. For details, check out the original paper.\n\n\nFigure 1: ConvNeXt performance (source: original paper).\n\n\n\nImplementation and weight porting\nThe ConvNeXt models are fairly easy to implement especially with the official PyTorch codebase available for reference. As mentioned before, these models can be implemented using the standard components provided in most of the major deep learning frameworks such as JAX, PyTorch, and TensorFlow.\nConvNeXt models use the following block structure with layer scaling as introduced in Going deeper with image transformers by Touvron et al.\n\n\n\n\n\n\nFigure 2: ConvNeXt block (source: original paper).\n\nThe skip connection is controlled with Stochastic Depth to induce regularization during training. Different ConvNeXt variants correspond to different depths along with different channels used in each of the stages. For example, the ‚Äútiny‚Äù variant uses the following setup:\ndepths = [3, 3, 9, 3]\ndims = [96, 192, 384, 768]\nIf you plan to populate the implemented models with the original parameters then it helps to align the architecture implementation with the official one as much as possible. Since I went with this approach I tried closely following the official implementation. My final implementation is available in this script. Note that, it does not yet include the isotropic ConvNeXt models.\nComing to the weight porting part, this is usually the most interesting part because there‚Äôs no standard recipe that‚Äôd work for all the models. You‚Äôll need to think about how to best align the original model parameters with your implementation.\nA ConvNeXt model is divided into three main parts: (1) stem which directly operates on the input image, (2) downsample blocks that reduce the resolution of feature maps as the network progresses, and (3) stages that apply the ConvNeXt blocks shown above. This is why I organized my weight porting script such that it has a correspondence between these different parts with the original parameters. Here is an example:\nfor layer in stem_block.layers:\n    if isinstance(layer, tf.keras.layers.Conv2D):\n        layer.kernel.assign(\n            tf.Variable(param_list[0].numpy().transpose(2, 3, 1, 0))\n        )\n        layer.bias.assign(tf.Variable(param_list[1].numpy()))\n    elif isinstance(layer, tf.keras.layers.LayerNormalization):\n        layer.gamma.assign(tf.Variable(param_list[2].numpy()))\n        layer.beta.assign(tf.Variable(param_list[3].numpy()))\nThe most difficult bit was figuring out how to properly populate the weights of the convolutional layers in TensorFlow from PyTorch. In an earlier implementation, I was simply using transpose(). The resulting models were giving poorer performance than expected. Vasudev helped me figure out the correct transposition of the weight axes and the models were then coming out as expected. More about the evaluation of these models in a moment.\nOnce the weights were ported successfully, the next task was to verify if the outputs of the intermediate layers matched with their original counterparts. One minor detail to note here is that the outputs of layers are not the same as their parameters. So, even if you check if the parameters of your implemented model and the original model are matching, their outputs could still mismatch. This mainly happens because of mismatches between the layer configurations of your model and the original one.\nThe final model conversion script is available here.\n\n\nEvaluation of the models\nTo be more certain, it‚Äôs also important to check the evaluation metrics of the converted models on the datasets used during training. In this case, we need to use the top-1 accuracy of the models on the ImageNet-1k dataset (validation set).\nTo set up this evaluation, I developed this notebook where I closely followed the preprocessing used in the official codebase for inference. The following table reflects the top-1 accuracies of the converted models along with the original scores reported here.\n\n\n\n\n\nName\n\n\nOriginal acc@1\n\n\nKeras acc@1\n\n\n\n\n\n\nconvnext_tiny_1k_224\n\n\n82.1\n\n\n81.312\n\n\n\n\nconvnext_small_1k_224\n\n\n83.1\n\n\n82.392\n\n\n\n\nconvnext_base_1k_224\n\n\n83.8\n\n\n83.28\n\n\n\n\nconvnext_base_1k_384\n\n\n85.1\n\n\n84.876\n\n\n\n\nconvnext_large_1k_224\n\n\n84.3\n\n\n83.844\n\n\n\n\nconvnext_large_1k_384\n\n\n85.5\n\n\n85.376\n\n\n\n\n\n\n\n\n\n\n\n\nconvnext_base_21k_1k_224\n\n\n85.8\n\n\n85.364\n\n\n\n\nconvnext_base_21k_1k_384\n\n\n86.8\n\n\n86.79\n\n\n\n\nconvnext_large_21k_1k_224\n\n\n86.6\n\n\n86.36\n\n\n\n\nconvnext_large_21k_1k_384\n\n\n87.5\n\n\n87.504\n\n\n\n\nconvnext_xlarge_21k_1k_224\n\n\n87.0\n\n\n86.732\n\n\n\n\nconvnext_xlarge_21k_1k_384\n\n\n87.8\n\n\n87.68\n\n\n\n\nKeras acc@1 refers to the scores of my implementation. Differences in the results are primarily because of the differences in the library implementations, especially how image resizing is implemented in PyTorch and TensorFlow. My evaluation logs are available at this URL. I‚Äôd like to thank Gus from the TF-Hub team for the productive discussions during this phase.\n\n\nPublishing on TF-Hub\nWith the models converted as expected, I was now tasked with publishing them on TF-Hub. These models can be categorized into two different variants: (1) off-the-shelf classifiers and (2) feature extractors used for downstream tasks. This means that the 15 model variants that I had converted would actually amount to 30 models.\nWhenever I publish models on TF-Hub, I try to accompany each model with the following:\n\nDocumentation that includes references of the models, how it was exported, etc.\nColab Notebook showing the model usage.\n\nDoing these things (especially the documentation part) for 30 models can be quite cumbersome. Willi from the TF-Hub team supported me in automatically generating documentation for 30 models. The script is available here. This script was basically generated from a documentation template and can be used for generating documentation when publishing more than one model. Additionally, I worked on a script that can archive the TensorFlow SavedModels in a way accepted by TF-Hub.\nI hope these scripts will be beneficial for anyone planning to contribute models to TF-Hub.\nAs of today, all 30 models are available on TF-Hub. They come with Colab Notebooks and documentation so that it‚Äôs easier to get started. Moreover, these TF-Hub models are not black-box SavedModels. You can load them as tf.keras.Model objects for further inspection. Here‚Äôs an example:\nmodel_gcs_path = \"gs://tfhub-modules/sayakpaul/convnext_tiny_1k_224/1/uncompressed\"\nmodel = tf.keras.models.load_model(model_gcs_path)\nprint(model.summary(expand_nested=True))\n\n\nWrapping up\nThat‚Äôs it for the post. We discussed a standard workflow that I use to publish models on TF-Hub and the difficulties that can arise during the process. I hope you‚Äôve found it to be worthy of your time and thank you for reading!\n\n\nAcknowledgements\n\nVasudev for helping with transposition bug\nGus for fruitful discussions\nWilli for helping with publishing\nML-GDE program for providing Google Cloud Platform credits"
  },
  {
    "objectID": "posts/distributed-training.html",
    "href": "posts/distributed-training.html",
    "title": "Distributed Training in TensorFlow with AI Platform & Docker",
    "section": "",
    "text": "Jupyter Notebooks are a great way to present your code offering a good level of interactivity, transparency, and reproducibility. However, operating with a Jupyter Notebook environment can get very challenging if you are working your way through large-scale training workflows as is common in deep learning.\nIf you are conducting large-scale training it is likely that you are using a powerful remote machine via SSH access. So, even if you are not using Jupyter Notebooks, problems like SSH pipe breakage, network teardown, etc. can easily occur. Consider using a powerful virtual machine on Cloud as your remote. The problem gets far worse when there‚Äôs a connection loss but you somehow forget to turn off that virtual machine to stop consuming its resources. You get billed for practically nothing when the breakdown happens until and unless you have set up some amount of alerts and fault tolerance.\nTo resolve these kinds of problems, we would want to have the following things in the pipeline:\n\nA training workflow that is fully managed by a secure and reliable service with high availability.\nThe service should automatically provision and de-provision the resources we would ask it to configure allowing us to only get charged for what‚Äôs been truly consumed.\nThe service should also be very flexible. It must not introduce too much technical debt into our existing pipelines.\n\nIn this post, we are going to consider all of these factors and will implement them using a service called AI Platform (provided by GCP) and Docker. We will use TensorFlow and Keras to handle distributed training to develop an image classification model capable of classifying cats and dogs. Apart from deep learning-related knowledge, a bit of familiarity would be needed to fully understand this post.\nAll the code presented throughout the post can be found here. We won‚Äôt be covering the entire codebase, instead, we will focus on the most important bits.\nIf you are like me, who have lost sleep over the very thought of the aforementioned problem, you will likely find this tutorial a good starting point to get around it.\n\nEnvironment setup\nYou will need to have Docker, command-line GCP (Google Cloud Platform) tools like gcloud, and TensorFlow (2.x) installed if you are on a local machine. But if you have a billing-enabled GCP project it‚Äôs possible to get started without any significant setup.\nWe will use a cheap AI Platform Notebook instance as our staging machine which we will use to build our custom Docker image, push it to Google Container Registry (GCR), and submit a training job to AI Platform. Additionally, we will use this instance to create TensorFlow Records (TFRecords) from the original dataset (Cats vs.¬†Dogs in this case) and upload them to a GCS Bucket. AI Platform notebooks come pre-configured with many useful Python libraries, Linux packages like docker, and also the command-line GCP tools like gcloud.\n\n\n\n\n\n\nNote\n\n\n\nI used an n1-standard-4 instance with TensorFlow 2.4 as the base image which costs $0.141 hourly.\n\n\n\n\nNotes on the task, data pipeline, and training\nTask\nAs mentioned earlier, we will be training an image classification model on the Cats vs.¬†Dogs dataset which is a moderate-sized dataset. The learning problem is a binary classification task.\nData pipeline\nFor setting up our data pipeline, we will first create shards of TFRecords from the original dataset. Each of the shards will contain batches of preprocessed images and their labels. This has an advantage. When we would load these shards back for training, we won‚Äôt need to do any preprocessing giving us a slight performance boost. Figure 1 demonstrates our TFRecords‚Äô creation workflow.\n\n\n\nFigure 1: Schematics of our TFRecord‚Äôs creation process.\n\n\n\nFigure 1: Schematics of our TFRecord‚Äôs creation process.\n\nAs you might have already noticed that we have also thrown in another component in the mix ‚Äì a GCS Bucket. We would need to store our data on a Google Cloud Storage (GCS) Bucket since the training code won‚Äôt be executed locally. We could have used other bucket services (like AWS S3) here but TensorFlow has very unified integrations with GCS Buckets, hence. We will be using the same GCS Bucket to store our trained model and also TensorBoard logs. The total cost to store all of these will be about $1.20.\nYou are welcome to check out the corresponding code here. In order to streamline the TFRecords‚Äô creation and upload process we will make use of a little shell script:\necho \"Uploading TFRecords to Storage Bucket...\"\necho gs://${BUCKET_NAME}\n\npython ../trainer/create_tfrecords.py\n\ngsutil -m cp -r train_tfr gs://${BUCKET_NAME}\ngsutil -m cp -r validation_tfr gs://${BUCKET_NAME}\n\ngsutil ls -lh gs://${BUCKET_NAME}\nAfter creating the TFRecords we simply copy them over to a previously created GCS Bucket. You can create one by executing the following: gsutil mb ${BUCKET_NAME}.\nTraining\nAs for the training pipeline, we will follow the steps below: - Load the TFRecords from GCS using CPU in a parallelized way using tf.data.Dataset.map() and feed batches of data to our model. For performance, we will also prefetch several future batches of data so that our model does not have to wait for the data to consume. Our data loader is present here in this script. - We will be using a pre-trained model to unleash the power of transfer learning. In particular, we will be using the DenseNet121 model that is available inside tf.keras.applications. - We will be training our model inside the tf.distribute.MirroredStrategy scope for distributed training. This strategy is applicable when we have a single host containing multiple GPUs. We will also be using mixed-precision training to speed up the process. The code for realizing this is here.\nThe training will take place on a remote machine fully managed by AI Platform.\nSo far, we have discussed the utilities for creating TFRecords, loading them, and building and training our model. Here‚Äôs how the code is structured in the GitHub repository mentioned at the beginning of the post:\n‚îú‚îÄ‚îÄ Dockerfile\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ config.yaml\n‚îú‚îÄ‚îÄ scripts\n‚îÇ   ‚îú‚îÄ‚îÄ train_cloud.sh\n‚îÇ   ‚îú‚îÄ‚îÄ train_local.sh\n‚îÇ   ‚îî‚îÄ‚îÄ upload_tfr.sh\n‚îî‚îÄ‚îÄ trainer\n    ‚îú‚îÄ‚îÄ config.py\n    ‚îú‚îÄ‚îÄ create_tfrecords.py\n    ‚îú‚îÄ‚îÄ data_loader.py\n    ‚îú‚îÄ‚îÄ model_training.py\n    ‚îú‚îÄ‚îÄ model_utils.py\n    ‚îú‚îÄ‚îÄ task.py\n    ‚îî‚îÄ‚îÄ tfr_utils.py\nNext, we will be reviewing how Docker fits into all these. From there on, we will have all the recipes set up to kickstart model training.\n\n\nFitting in Docker\nTo submit custom training jobs to AI Platform, we need to package our code inside a Docker image. So, let‚Äôs start with that.\nTo build a Docker image, we first need to define a Dockerfile specifying how it should itself up. Google Container Registry (GCR) provides CUDA-configured TensorFlow containers that we can use to build custom ones. In our case, we extend one such container. Our Dockerfile looks like so:\n# Use an existing CUDA-configured TensorFlow container\nFROM gcr.io/deeplearning-platform-release/tf2-gpu.2-4\nWORKDIR /root\n\n# Update TensorFlow to the latest version (2.4.1 at the\n# time of writing).\nRUN pip install -U tensorflow\n\n# Copies the trainer code to the docker image.\nCOPY trainer/config.py ./trainer/config.py\nCOPY trainer/data_loader.py ./trainer/data_loader.py\nCOPY trainer/model_utils.py ./trainer/model_utils.py\nCOPY trainer/model_training.py ./trainer/model_training.py\nCOPY trainer/task.py ./trainer/task.py\n\n# Set up the entry point to invoke the trainer.\nENTRYPOINT [\"python\"]\nCMD [\"trainer/task.py\"]\nAfter we have defined the Dockerfile, we can proceed to build it and do a round of model training by locally running it.\n\n\nBuilding and locally running our container\nWe will be using GCR to manage the lifecycle of our container. To build a Docker container, one must provide a correct Image URI (Uniform Resource Identifier) and it depends on the platform you are using for managing your container. In our case, that is GCR.\nFor GCR, the format of the image goes like the following: gcr.io/${PROJECT_ID}/${IMAGE_REPO_NAME}:${IMAGE_TAG}, where PROJECT_ID is the ID of your GCP project and IMAGE_REPO_NAME and IMAGE_TAG are identifiers.\nWe then build our image and locally run it:\n$ docker build -f Dockerfile -t ${IMAGE_URI} ./\n$ docker run ${IMAGE_URI} \\\n    trainer/task.py --bucket ${BUCKET_NAME} \\\n    --train-pattern ${TRAIN_FILES} \\\n    --valid-pattern ${VALIDATION_FILES}\nTo make the process cleaner, we can create a shell script and put all the instructions inside it. You can follow this one to get an idea.\nThe first time it‚Äôs run, it‚Äôs going to take a while. But after that, all the consequent runs will use the cached resources to speed up the build. The local Docker daemon (dockerd) will first read our Dockerfile and after getting to the entry point, it will parse all the command-line arguments we provided to task.py. task.py just takes all the command-line arguments and starts the model training. TRAIN_FILES and VALIDATION_FILES are patterns to the TFRecords residing inside a GCS Bucket and they look like so -\nTRAIN_FILES=gs://${BUCKET_NAME}/train_tfr/*.tfrec\nVALIDATION_FILES=gs://${BUCKET_NAME}/validation_tfr/*.tfrec\nIf everything goes well, then, after a while, you should be able to see that our model has started training:\n\n\nFigure 2: Docker build.\n\n\n\nFigure 3: Local training logs.\n\nThe local Docker run is a way for us to ensure our code is running fine without any hiccups. So, it‚Äôs advisable to stop the local run after you have ensured the model is able to start training. With this, we are now ready to push our custom Docker image to GCR, and submit a training job to AI Platform.\n\n\nSubmitting a training job\nFor this step, we need to add two more lines of code: * After building our Docker image, we need to push it to GCR so that AI Platform can pull it to run model training. * Submit a training job to AI Platform.\nSo, let‚Äôs put these pieces together:\n# Build and push the docker image\n$ docker build -f Dockerfile -t ${IMAGE_URI} ./\n$ docker push ${IMAGE_URI}\n\n# Submit job\n$ gcloud ai-platform jobs submit training ${JOB_NAME} \\\n    --region ${REGION} \\\n    --master-image-uri ${IMAGE_URI} \\\n    --config ./config.yaml \\\n    -- \\\n    trainer/task.py --bucket ${BUCKET_NAME} \\\n    --train-pattern ${TRAIN_FILES} \\\n    --valid-pattern ${VALIDATION_FILES}\nReviewing what‚Äôs going on with the gcloud command, we have:\n\nregion, that informs AI Platform about the region to be used for the training process. This very region is also going to be used to provision resources such as GPUs. If GPUs are to be used then it‚Äôs important to pass a region that has that support. You can know the regions that have this support from here.\nmaster-image-uri is the URI of our custom Docker image.\nVia config, we provide a specification of the kind of machine we want to use for training. This specification is provided using a YAML file and ours looks like so:\ntrainingInput:\n  scaleTier: CUSTOM\n  # Configure a master worker with 2 V100 GPUs\n  masterType: n1-standard-8 # Specify the base machine type\n  masterConfig:\n    acceleratorConfig:\n      count: 2\n      type: NVIDIA_TESLA_V100\nThe advantage of using specifications like this lies in the flexibility it provides. The gcloud ai-platform jobs submit training command has a scale-tier option through which we can pass a pre-defined machine configuration. But let‚Äôs say we want to train using multiple machines - 1 master, 3 workers, and 3 parameter servers each having different GPU and CPU configurations. The pre-defined values won‚Äôt cut here and this is where we can take the advantage of custom specifications. You can check here to know the different machine types and configurations that can be provided to AI Platform.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nWe are using V100 GPUs because they come with Tensor cores and that is a must-have to take the advantage of mixed-precision training. We could have used other GPUs like T4, A100 as well that fit this criterion.\n\n\n\nWe have already discussed the part that follows config so we will not be reviewing that here. If the job submission is successful you should see an entry for it on the GCP console:\n\n\nFigure 4: AI Platform training job list.\n\nOn the extreme right, you would notice an option called View Logs that lets us monitor our training. It‚Äôs incredibly useful to have all of your training logs stored somewhere safe without making any effort. Logging for an AI Platform training job is managed by Cloud Logging. Here‚Äôs how mine looks like:\n\n\nFigure 5: Training logs. Notice the neat search filter query.\n\nAfter training is complete, we can verify if all the necessary artifacts were stored inside our GCS Bucket:\n\n\nFigure 6: SavedModel file and TensorBoard logs.\n\nIn our training script, we had set up the TensorBoard callback to keep track of the training progress. You can check one such log here online on tensorboard.dev. Inspecting into it, we can see that our model‚Äôs been trained well, as the validation accuracy has stabilized:\n\n\nFigure 7: Accuracy plot.\n\nAs an effective practitioner, It‚Äôs important to be aware of the costs and ensure maximization of resource utilization. Now that we were able to successfully complete our model training, let‚Äôs discuss these aspects in the next and final section of the post.\n\n\nDelving deep into training costs and resource utilization\nAI Platform provides a number of useful metrics for the training jobs. Each job has a separate dashboard that makes it super easy to keep track of its statistics such as total training time, average resource utilization, etc.\nFirst, we have high-level information about the job:\n\n\nFigure 8: High-level information about a training job.\n\nWe can see that the job takes about 22 minutes to complete, and this includes the provisioning of resources, completing the model training, and de-provisioning the resources. We then see the total ML units consumed to run our job. The cost for this translates to:\n1.79 (Consumed ML units) \\(\\times\\) USD 0.49 = USD 0.8771\nYou can refer to this document that details the cost calculation scheme. GCP also provides a handy estimated cost calculator that you can find here.\nSo far our costs are: USD 0.141 (AI Platform Notebook) + USD 1.20 (GCS) + USD 0.8771 (training job) = USD 2.2181. Let‚Äôs compare this to an AI Platform Notebook instance equipped with the similar configurations as the one we used for training:\n\n\nFigure 9: Cost for an AI Platform Notebook with 2 V100 GPUs with n1-standard-8.\n\nComing to CPU utilization, we have some room for improvement it seems:\n\n\nFigure 10: CPU utilization of our training resources.\n\nThe overall GPU utilization has a few spikes which might need some more inspections in the future:\n\n\nFigure 11: GPU utilization of our training resources.\n\n\n\nConclusion\nWe have covered quite a lot of ground in this post. I hope by now you have an idea of how to combine tools like Docker, AI Platform to manage your large-scale training workflows in a more cost-effective and scalable way. As a next step, you could take the trained model from AI Platform and deploy the model using it. AI Platform predict jobs make it easier to expose models via REST API-like services that are fully managed by AI Platform offering things like autoscaling, authorization, monitoring, etc. If you‚Äôd like to try it out yourself, I encourage you to check out the code of this post on GitHub. You are also welcome to checkout TensorFlow Cloud that provides a set of tools making it easier to perform large-scale training with GCP.\n\n\nAcknowledgements\nI am thankful to Karl Weinmeister for his comments on the initial draft of this post. Also, thanks to the ML-GDE program for providing generous GCP support without which I couldn‚Äôt have executed the experiments."
  },
  {
    "objectID": "posts/2020-08-02-favorite-recipes-vision.html",
    "href": "posts/2020-08-02-favorite-recipes-vision.html",
    "title": "A few favorite recipes in computer vision & deep learning",
    "section": "",
    "text": "A few days ago from the time of writing this blog post I tweeted -\nIn this blog post, I will expand on this tweet to convey why these are my favorite recipes among other things.\nThe training frameworks I mentioned can be classified into two broad categories -"
  },
  {
    "objectID": "posts/2020-08-02-favorite-recipes-vision.html#labels-contrastive-loss-win-win",
    "href": "posts/2020-08-02-favorite-recipes-vision.html#labels-contrastive-loss-win-win",
    "title": "A few favorite recipes in computer vision & deep learning",
    "section": "Labels + contrastive loss = win-win",
    "text": "Labels + contrastive loss = win-win\nSupervised Contrastive Learning addresses a very important point about the self-supervised learning frameworks like SimCLR. In SimCLR, the positive pairs are generated by taking different views of the same image and the negative pairs are then randomly sampled from the other images present in a batch.\n\nHere are some examples of negative pairs -\n\nAs discussed in the Supervised Contrastive Learning paper, this method of contrasting two different views of the same image can result in false negatives i.e.¬†the samples belonging to the same class might get mapped differently in the embedding space. There‚Äôs no way for us to properly mitigate this issue without having access to the original labels. Hence, I mentioned if you have loads of labeled images, it‚Äôs better to use Supervised Contrastive Learning to capture meaningful representations.\n\nSupervised Contrastive Learning extends how we train supervised models by introducing a two stage training framework. In the first stage, it uses the label information in the contrastive loss to learn to map the encoded representations effectively. In the second stage, it train a linear model on top of these encoded representations for the given supervised training objective.\nIn practice this works quite well -\n\nYou might be feeling very tempted to try out this on your labeled dataset. Truth be told - Supervised Contrastive Learning is also compute-intensive even for relatively small datasets. So, if you don‚Äôt have the training budget you might need to reconsider this option.\nMaybe you have a relatively smaller labeled dataset and you just want to be able to fine-tune a good enough architecture which is still very useful for many practical scenarios. This is where BigTransfer can really shine."
  },
  {
    "objectID": "posts/augmentation-recipes.html",
    "href": "posts/augmentation-recipes.html",
    "title": "Different data augmentation recipes in tf.keras for image classification",
    "section": "",
    "text": "Data augmentation is a favorite recipe among deep learning practitioners especially for the ones working in the field of computer vision. Data augmentation is a technique used for introducing variety in training data thereby helping to mitigate overfitting.\nWhen using Keras for training image classification models, using the ImageDataGenerator class for handling data augmentation is pretty much a standard choice. However, with TensorFlow, we get a number of different ways we can apply data augmentation to image datasets. In this tutorial, we are going to discuss three such ways. Knowing about these different ways of plugging in data augmentation in your image classification training pipelines will help you decide the best way for a given scenario.\nHere‚Äôs a brief overview of the different ways we are going to cover:\n\nUsing the standard ImageDataGenerator class\nUsing TensorFlow image ops with a TensorFlow dataset\nUsing Keras‚Äôs (experimental) image processing layers\nMix-matching different image ops & image processing layers\n\nLet‚Äôs get started!\n\nExperimental setup\nWe are going to use the flowers dataset to demonstrate the experiments. Downloading the dataset is just as easy as executing the following line of code:\nflowers contains the path (which in my case is - /root/.keras/datasets/flower_photos) where the dataset got downloaded. The structure of the dataset looks like so -\n‚îú‚îÄ‚îÄ daisy [633 entries]\n‚îú‚îÄ‚îÄ dandelion [898]\n‚îú‚îÄ‚îÄ roses [641]\n‚îú‚îÄ‚îÄ sunflowers [699 entries]\n‚îú‚îÄ‚îÄ tulips [799 entries]\n‚îî‚îÄ‚îÄ LICENSE.txt\n\n# Get the flowers dataset\nflowers = tf.keras.utils.get_file(\n    'flower_photos',\n    'https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz',\n    untar=True)\n\nUsing the standard ImageDataGenerator class For most of the scenarios, the ImageDataGenerator should be good enough. Its flexible API design is really to follow and it makes it easier to work with custom image datasets by providing meaningful high-level abstractions.\nWe instantiate the ImageDataGenerator class like so -\n\nimg_gen = tf.keras.preprocessing.image.ImageDataGenerator(\n    rescale=1./255,\n    rotation_range=30,\n    horizontal_flip=True)\n\nWe specify two augmentation operations and a pixel rescaling operation in there. ImageDataGenerator comes with a handy flow_from_directory method that allows us to read images from a directory and apply the specified operations on the fly during the time of training. Here‚Äôs how to instruct the img_gen object to read images from a directory -\n\nIMG_SHAPE = 224\nBATCH_SIZE = 32\n\nimg_flow = img_gen.flow_from_directory(flowers, \n    shuffle=True, \n    batch_size=BATCH_SIZE,\n    target_size=(IMG_SHAPE, IMG_SHAPE))\n\nFound 3670 images belonging to 5 classes.\n\n\nWe then verify the images and the labels and they are indeed parsed right -\n\nimages, labels = next(img_flow)\nprint(images.shape, labels.shape)\nshow_batch(images, labels)\n\n(32, 224, 224, 3) (32, 5)\n\n\n\n\n\n\n\n\n\nTraining with an ImageDataGenerator instance is extremely straight-forward -\nmodel = get_training_model()\nmodel.fit(img_flow, ...)\nFor a fully worked out example, refer to this tutorial.\nAs can be seen in this blog post, ImageDataGenerator‚Äôs overall data loading performance can have a significant effect on how fast your model trains. To tackle situations, where you need to maximize the hardware utilization without burning unnecessary bucks, TensorFlow‚Äôs data module can be really helpful (comes at some costs).\n\n\nTensorFlow image ops with tf.data APIs\nThe blog post I mentioned in the previous section shows the kind of performance boost achievable with tf.data APIs. But it‚Äôs important to note that boost comes at the cost of writing boilerplate code which makes the overall process more involved. For example, here‚Äôs how you would load and preprocess your images and labels -\n\ndef parse_images(image_path):\n    # Load and preprocess the image\n    img = tf.io.read_file(image_path) # read the raw image\n    img = tf.image.decode_jpeg(img, channels=3) # decode the image back to proper format\n    img = tf.image.convert_image_dtype(img, tf.float32) # scale the pixel values to [0, 1] \n    img = tf.image.resize(img, [IMG_SHAPE, IMG_SHAPE]) # resize the image\n\n    # Parse the labels\n    label = tf.strings.split(image_path, os.path.sep)[5]\n\n    return (img, label)\n\nYou would then write a separate augmentation policy with the TensorFlow Image ops -\n\ndef augment(image, label):\n    img = tf.image.rot90(image)\n    img = tf.image.flip_left_right(img)\n    return (img, label)\n\nTo chain the above two together you would first create an initial dataset consisting of only the image paths -\n\nimage_paths = list(paths.list_images(flowers))\nlist_ds = tf.data.Dataset.from_tensor_slices((image_paths))\n\nNow, you would read, preprocess, shuffle, augment, and batch your dataset -\n\nAUTO = tf.data.experimental.AUTOTUNE\n\ntrain_ds = (\n    list_ds\n    .map(parse_images, num_parallel_calls=AUTO)\n    .shuffle(1024)\n    .map(augment, num_parallel_calls=AUTO) # augmentation call\n    .batch(BATCH_SIZE)\n    .prefetch(AUTO)\n)\n\nnum_parallel_calls allows you to parallelize the mapping function and tf.data.experimental.AUTOTUNE lets TensorFlow decide the level of parallelism to use dynamically (how cool is that?). prefetch allows loading in the next batch of data well before your model finishes the current epoch of training. It is evident that this process is more involved than the previous one.\nVerifying if we constructed the data input pipeline correctly is a vital step before you feed your data to the model -\n\nimage_batch, label_batch = next(iter(train_ds))\nprint(image_batch.shape, label_batch.shape)\nshow_batch(image_batch.numpy(), label_batch.numpy(), image_data_gen=False)\n\n(32, 224, 224, 3) (32,)\n\n\n\n\n\n\n\n\n\nThe ‚Äúb‚Äùs appear before the class labels because TensorFlow parses the strings as byte-strings. Using train_ds with your model is also just about executing -\nmodel = get_training_model()\nmodel.fit(train_ds, ...)\nHere you can find a fully worked out example. Here you can know more about the different performance considerations when using tf.data. There are more image ops available with TensorFlow Addons which can found here.\nRecently, Keras introduced image_dataset_from_directory function (only available in tf-nightly at the time of writing this) which takes care of many of the boilerplate code we saw above and still yields pretty good performance. Here‚Äôs a tutorial that shows how to use it.\nKeras has also introduced a number of image processing layers which can be very useful to build flexible augmentation pipelines using the Sequential API. In the next section, let‚Äôs see how.\n\n\nUsing Keras‚Äôs (experimental) image processing layers\nJust like you would construct an entire model using the Sequential API, you can now construct very flexible data augmentation pipelines using the newly introduced (although experimental at the time of writing this) image processing layers. If we were to convert the data augmentation operations we have been following in the tutorial so far, building a data augmentation pipeline using this approach would be like so -\n\ndata_augmentation = tf.keras.Sequential([\n    tf.keras.layers.experimental.preprocessing.RandomFlip('horizontal'),\n    tf.keras.layers.experimental.preprocessing.RandomRotation(0.3)\n])\n\nBefore passing your data through this stack of layers makes sure you haven‚Äôt applied any augmentation already. So, it‚Äôs safe to create a separate TensorFlow dataset without mapping the augmentation function like we previously did -\n\n# Create TensorFlow dataset without any augmentation\ntrain_ds = (\n    list_ds\n    .map(parse_images, num_parallel_calls=AUTO)\n    .shuffle(1024)\n    .batch(BATCH_SIZE)\n    .prefetch(AUTO)\n)\n\nNow, we can see how to examine some of the augmented images that would come out of this mini pipeline -\n\nimage_batch, label_batch = next(iter(train_ds))\n\nplt.figure(figsize=(10, 10))\nfor n in range(25):\n    ax = plt.subplot(5, 5, n+1)\n    augmented_image = data_augmentation(tf.expand_dims(image_batch[n], 0))\n    plt.imshow(augmented_image[0].numpy())\n    plt.title(label_batch[n].numpy().decode(\"utf-8\"))\n    plt.axis('off')\n\n\n\n\n\n\n\n\nWe can also make use of Python lambdas to map data_augmentation directly to our tf.data pipeline like so:\ntrain_ds = (\n    list_ds\n    .map(parse_images, num_parallel_calls=AUTO)\n    .shuffle(1024)\n    .batch(BATCH_SIZE)\n    .map(lambda x, y: (data_augmentation(x), y),\n        num_parallel_calls=AUTO)\n    .prefetch(AUTO)\n)\nNote that these layers can be also added as a part of your model allowing them to run on GPUs. Based on your compute budget you should decide if you would want to run these layers on the GPU or you would rather have them executed separately on the CPU.\nA functional model definition in Keras using this approach may look like so -\n# You define an input layer with pre-defined shapes\ninputs = keras.Input(shape=(IMG_SHAPE, IMG_SHAPE, 3))\n\nx = data_augmentation(inputs)  # Apply random data augmentation\nx = feature_extractor_model(x, training=False)\nx = GlobalAveragePooling2D()(x)\nx = Dropout(0.2)(x)  \noutputs = Dense(1)(x)\n\nmodel = Model(inputs, outputs)\nNow, model should be good to go with - model.fit(train_ds, ...). A fully worked out example is available here. Note that, performance might get slightly affected when going with this approach since the GPUs will be utilized to run the preprocessing layers as well.\nLet‚Äôs now think about situations where we may need to use a combination of the image ops of TensorFlow and the layers we just saw. What if we need to plug in custom augmentation operations in the augmentation pipeline? Added on top of it, what if we need to fix the probability at which the augmentation operations would get applied? Data augmentation pipelines are quite central behind the success of recent works like SimCLR, Augmix, etc.\n\n\n\n\n\n\nNote\n\n\n\nThese layers have pre-defined inference-time behaviour. So even if you have included them inside your model itself, it‚Äôs totally fine. But if you want them during inference, you would need to set its inference-time behaviour.\n\n\n\n\nTowards more complex augmentation pipelines\nIn this final approach, we will see how to mix and match between the different stock image ops, and stock image processing layers. Let‚Äôs first define a class utilizing the stock image ops with a utility function to apply them at random with a pre-defined probability.\n\nclass CustomAugment(object):\n    def __call__(self, image):        \n        # Random flips and grayscale with some stochasticity\n        img = self._random_apply(tf.image.flip_left_right, image, p=0.6)\n        img = self._random_apply(self._color_drop, img, p=0.9)\n        return img\n\n    def _color_drop(self, x):\n        image = tf.image.rgb_to_grayscale(x)\n        image = tf.tile(x, [1, 1, 1, 3])\n        return x\n    \n    def _random_apply(self, func, x, p):\n        return tf.cond(\n          tf.less(tf.random.uniform([], minval=0, maxval=1, dtype=tf.float32),\n                  tf.cast(p, tf.float32)),\n          lambda: func(x),\n          lambda: x)\n\n_random_apply is taken from the official SimCLR repository. Now, in order to tie it together with the stock image processing layers, we can still use the Sequential API with a Lambda layer -\n\n# Build the augmentation pipeline\ndata_augmentation = tf.keras.Sequential([\n    tf.keras.layers.Lambda(CustomAugment()),\n    tf.keras.layers.experimental.preprocessing.RandomRotation(0.1)\n])\n\nWhen we verify if it‚Äôs indeed correct, we get desired outputs -\n\nimage_batch, label_batch = next(iter(train_ds))\n\nplt.figure(figsize=(10, 10))\nfor n in range(25):\n    ax = plt.subplot(5, 5, n+1)\n    augmented_image = data_augmentation(tf.expand_dims(image_batch[n], 0))\n    plt.imshow(augmented_image[0].numpy())\n    plt.title(label_batch[n].numpy().decode(\"utf-8\"))\n    plt.axis('off')\n\n\n\n\n\n\n\n\nTraining models when using this approach remains the same as the previous one. Keep in mind that performance can get affected when using this approach.\n\n\nReferences\n\nFine-tuning with Keras and Deep Learning\nTransfer learning & fine-tuning\nImage classification from scratch\nData augmentation"
  },
  {
    "objectID": "posts/gsoc-faqs.html",
    "href": "posts/gsoc-faqs.html",
    "title": "First Steps in GSoC",
    "section": "",
    "text": "In this post, I discuss my perspective on two primary questions pertaining to the Google Summer of Code (GSoC) program. Even though my work is centered around Machine Learning (ML), I believe these pointers are domain-agnostic. This is based on my experience of mentoring for TensorFlow at GSoC 2021. Please note that these thoughts are of my own and may not reflect what anyone else (including the program organizers and my employer) thinks."
  },
  {
    "objectID": "posts/gsoc-faqs.html#how-should-i-get-started",
    "href": "posts/gsoc-faqs.html#how-should-i-get-started",
    "title": "First Steps in GSoC",
    "section": "How should I get started?",
    "text": "How should I get started?\nFirst and foremost, it‚Äôs important to acknowledge that GSoC requires some amount of open-source experience beforehand. That not only makes your application stronger but also sets you up for the program itself. But beyond everything else, having a genuine passion for contributing to open-source is important and is a key enabling factor. Open-source should be a fun engagement driven by your passion for helping a community. So, ensure you‚Äôre chasing the right things.\n\nUnderstand what GSoC is, how it works, what are the rules, and study some projects from the previous years by going to GSoC‚Äôs official website: ‚Äã‚Äãhttps://summerofcode.withgoogle.com/.\nHere‚Äôs another resource that might be equally helpful. It‚Äôs important that you set your expectations right from the very beginning. Sometimes having conversations with the past GSoC contributors is really helpful in this regard. \nTake a look at the organizations taking part in GSoC. You‚Äôll notice that they have all their projects listed for which they are welcoming contributions. \nStudy all the official resources that are out there for the project you want to contribute to. You may be interested in multiple projects but it helps to laser focus on one so that you can precisely figure out what components you‚Äôd want to work on, your timeline, etc. \nGet started contributing. Here are some good examples that make it clear what a GSoC contributor should do first:\n\nArduPilot\nGNOME\nPerformance Co-Pilot\nRoboComp\nWikimedia Foundation \n\nSometimes a project may not require having prior contribution experience but having it is almost always better. TensorFlow Hub (TF-Hub) is one such example where you‚Äôre generally asked to code a ML model, (optionally) train it, and host the model on TF-Hub thereby making it easier for the community to use the model. \nLastly, if you haven‚Äôt worked with a version control system before definitely spend time doing that. Git is a good example of such a system and here‚Äôs a good course from Udacity that can be helpful."
  },
  {
    "objectID": "posts/gsoc-faqs.html#what-makes-a-proposal-great",
    "href": "posts/gsoc-faqs.html#what-makes-a-proposal-great",
    "title": "First Steps in GSoC",
    "section": "What makes a proposal great?",
    "text": "What makes a proposal great?\nFirstly, I‚Äôd like to acknowledge that the answers to this question should be subjective. That said, I think there are certain common aspects that are shared by all great GSoC proposals.\n\nGSoC is about building things. So including your experience that reflects the same immediately catches the eye. You build that experience over a period of time, it‚Äôs not something built overnight. That way, your experience speaks about a few things: consistency, technical depth, punctuality, communication, etc. Let me provide some examples.  Say, you wanted to contribute to KerasCV by adding a new layer(s) to it. If you can show that you‚Äôve already worked on something that reflects the experience relevant to the contribution, it puts you in a better position than someone without that experience.\nSimilarly, if you wanted to contribute a model to TF-Hub, it helps to show that you‚Äôve experience implementing models and relevant things such as layers, blocks, etc. \nWhen you‚Äôre talking about an experience in your proposal be sure to back it with verifiable links. Without that, the mention becomes practically void. \nDon‚Äôt just mention the components of the project you‚Äôd like to work on. Include all the nitty-gritty of that ‚Äì why you‚Äôd like to work on them and why it‚Äôs useful, what your approaches will be, etc. If you anticipate some edge cases or blockers include them too. This speaks volumes about your maturity. \nKeep your proposal grammatically correct and easily understandable. This helps you communicate your proposal better. Remember that it‚Äôs your responsibility to ensure that your proposal was communicated in an expected way. \nSometimes, applications come with incomplete sentences, inconsistency in sentence casing, without punctuations, etc. This is an anti-pattern. Try hard to ensure your proposal doesn‚Äôt have those things. This may readily reduce the seriousness of your proposal and the work you put into it. \nInclude a realistic timeline that covers the project deliverables and includes enough time for you and the mentors to communicate effectively. Unexpected things can happen all the time so, it helps to also include some extra time to dedicate to those situations.\n\nSometimes, a project may welcome ideas from the contributors. If you‚Äôd like to propose something that‚Äôs already not enlisted in a project, be sure to reach out to the project mentor to discuss the feasibility of your idea before working on the proposal."
  },
  {
    "objectID": "posts/gsoc-faqs.html#additional-notes",
    "href": "posts/gsoc-faqs.html#additional-notes",
    "title": "First Steps in GSoC",
    "section": "Additional notes",
    "text": "Additional notes\nDuring GSoC 2021, I had the opportunity to work with Aditya Kane and Vausdev Gupta as their mentor. Here are their GSoC proposals:\n\nAditya\nVasudev\n\nI‚Äôm fortunate to be mentoring for TensorFlow at GSoC 2022 as well. If you‚Äôre curious, I have a presentation that discusses how open-source can enable different possibilities in the ML world. If you‚Äôre looking for an example of a non-ML proposal, then Anubhav Singh‚Äôs proposal is a great example.\nAdditionally, we penned down our mentorship experience in this blog post that may provide additional context."
  },
  {
    "objectID": "posts/optimizing-text-detectors.html",
    "href": "posts/optimizing-text-detectors.html",
    "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST",
    "section": "",
    "text": "In the previous post, we saw how to convert the pre-trained CRAFT model from PyTorch to TensorFlow Lite (TFLite) and run inference with the converted TFLite model. In this post, we will be comparing the TFLite variants of the CRAFT model to another text detection model - EAST. The objective of this post is to provide a comparative study between these two models with respect to various deployment-specific pointers such as inference latency, model size, performance on dense text regions, and so on. Text detection continues to be a very important use-case across many verticals. So we hope this post will serve as a systematic guide for developers that are interested to explore on-device text detection models.\nPrecisely, we will be comparing the two models on the basis of the following pointers which we think are very crucial when it comes to deploying them out in the wild -"
  },
  {
    "objectID": "posts/optimizing-text-detectors.html#benchmark-setup",
    "href": "posts/optimizing-text-detectors.html#benchmark-setup",
    "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST",
    "section": "Benchmark Setup",
    "text": "Benchmark Setup\nWe used the TensorFlow Lite Benchmark tool in order to gather results on inference latency and memory usage of the models with Redmi K20 Pro as the target device. We chose a mobile device for this purpose because text detection is a pretty prevalent recipe of many mobile applications such as Google Lens.\nIn order to make the comparisons fair, we consider the two models with three different image resolutions - 320x320, 640x416, and 1200x800. For each of these resolutions, we consider two different post-training quantization schemes - dynamic-range and float16. The CRAFT model conversion is not yet supported in the integer variant, hence we do not consider integer quantization (but the EAST model does support it)."
  },
  {
    "objectID": "posts/optimizing-text-detectors.html#visual-inspection-of-performance",
    "href": "posts/optimizing-text-detectors.html#visual-inspection-of-performance",
    "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST",
    "section": "Visual Inspection of Performance",
    "text": "Visual Inspection of Performance\nIn this setting, we run both of the models and their different variants (dynamic-range and float16 quantized) on a sample image that has dense text regions, and then we visualize the results. We observed that both of these models perform fairly well on images having lighter text regions. Here‚Äôs the sample image we used for the purpose -\n\n\nImage is taken from the SROIE dataset.\n\nTime to detect some texts!\n\nCRAFT - 320x320 Dynamic-Range & float16\nIn the dynamic-range quantization setting, we can see the model misses out on some text blocks.\n\n\nInference results from the 320x320 dynamic-range and float16 quantized CRAFT models.\n\nWith increased numerical precision i.e.¬†float16, we can clearly see quite a bit of improvement in the results. It‚Äôs important to note that this improvement comes at the cost of increased model size.\nNext up, we apply the same steps to the EAST model.\n\n\nEAST - 320x320 Dynamic-Range & float16\nEAST apparently performs better than CRAFT under dynamic-range quantization. If we look closely, it appears that the CRAFT model produces far fewer overlaps in the detections compared to EAST. On the other hand, the EAST model is able to detect more text blocks. When developing practical applications with text detectors, it often becomes a classic case of precision-recall trade-offs like the one we are currently seeing. So, you would want to consider the application-specific needs in order to decide the level of trade-off to be achieved there.\n\n\nInference results from the 320x320 dynamic-range and float16 quantized EAST models.\n\nWith increased precision, the above-mentioned points still hold, i.e.¬†the number of overlaps being way higher for the EAST model than they are in the CRAFT equivalent. In this setting (float16 quantization), superiority in the performance of the CRAFT model is quite evident in regards to the EAST model.\nAs different applications may use different image resolutions we decided to test the performance of the models on larger dimensions as well. This is what we are going to see next.\n\n\nCRAFT - 640x416 Dynamic-Range & float16\nOn an increased resolution, the CRAFT model performs pretty well -\n\n\nInference results from the 640x416 dynamic-range and float16 quantized CRAFT models.\n\nThe float16 version of this resolution is a slam dunk (rightfully leaving behind the barcode which is not a piece of text).\n\n\nEAST - 640x416 Dynamic-Range & float16\nThe performance of the EAST model under these settings are very equivalent to CRAFT -\n\n\nInference results from the 640x416 dynamic-range and float16 quantized EAST models.\n\nWith float16 quantization and 640x416 as the resolution, the CRAFT model is a clear winner. Notice that the EAST model is still unable to discard the barcode part which might be an important point to note for some applications.\nTime to inspect the results for our final and highest resolution - 1280x800.\n\n\nCRAFT - 1280x800 Dynamic-Range & float16\nUnder dynamic-range quantization, the results look okayish. The model misses out on a number of text blocks but the only ones that it detects appear to be neat.\n\n\nInference results from the 1280x800 dynamic-range and float16 quantized CRAFT models.\n\nThe results from the float16 variant are tremendous (as you probably have guessed by now).\n\n\nEAST - 1280x800 Dynamic-Range & float16\nAt this resolution, the EAST model seems to be performing well too -\n\n\nInference results from the 1280x800 dynamic-range and float16 quantized EAST models.\n\nWith float16 quantization as well, the CRAFT model beats EAST in terms of the detection quality."
  },
  {
    "objectID": "posts/optimizing-text-detectors.html#model-size",
    "href": "posts/optimizing-text-detectors.html#model-size",
    "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST",
    "section": "Model Size",
    "text": "Model Size\nWhen it comes to deploying models to mobile devices model size becomes a really important factor. You may not want to have a heavy model that would, in turn, make your mobile application bulky. Moreover, Playstore and AppStore also have size restrictions on the applications one can host there.\nOn the other hand, heavier models tend to be slower. If your application cannot have increased inference latency then you would want to have the model size as low as possible.\nThe following figure shows the size of the CRAFT and EAST models -\n\n\nModel (TFLite variants) sizes of CRAFT and EAST.\n\nThe dynamic-range quantized versions of both the models are in a well-acceptable range with respect to size. However, the float16 variants may still be a bit heavier for some applications."
  },
  {
    "objectID": "posts/optimizing-text-detectors.html#inference-latency",
    "href": "posts/optimizing-text-detectors.html#inference-latency",
    "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST",
    "section": "Inference Latency",
    "text": "Inference Latency\nInference latency is also one of the major factors for mobile-based deployments especially when your applications might require instantaneous predictions. We are going to show a comparison between all the settings we considered in the visual inspection section.\nTo reiterate we performed the benchmarks for this section on a Redmi K20 Pro using 4 threads. In the following figures, we present inference latency of different variants of the CRAFT and EAST models.\n\n\nInference latency of different variants of the CRAFT model.\n\n\n\nInference latency of different variants of the EAST model.\n\nAs expected, with increased resolution the inference latency also increases. Inference latency is also quite lower for all the variants of the EAST model compared to CRAFT. Earlier we saw how a quantization affects model performance under a particular resolution. As stated earlier, when using these models inside a mobile application, the ‚ÄúSize vs.¬†Performance‚Äù trade-off becomes extremely vital.\n\nimportant: The results for the float16 1280x800 CRAFT model could not be obtained on our target device."
  },
  {
    "objectID": "posts/optimizing-text-detectors.html#memory-usage",
    "href": "posts/optimizing-text-detectors.html#memory-usage",
    "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST",
    "section": "Memory Usage",
    "text": "Memory Usage\nIn section, we shed light on the total memory allocated for the models while running the TensorFlow Lite Benchmark tool. Knowing about the memory usage of these models helps us plan application releases accordingly as not all the mobile phones may support extensive memory requirements. So based on this information, you may want to set some device requirements for your application using these models. On the other hand, if you would want your application to be as device-agnostic as possible then you may want to maintain separate models according to their size and memory usage.\nIn this case, also, we are going to consider all the settings we had considered in the previous sections. The following figures give us a sense of the memory footprint left behind by the models -\n\n\nMemory footprint of different variants of the CRAFT model.\n\n\n\nMemory footprint of different variants of the EAST model.\n\nDetection performance-wise, CRAFT was a winner in many cases but if we factor in for inference latency and memory footprint the situation might need reconsideration. In other words, the best performing (with respect to a certain task, detection in this case) model may not always be the best candidate for deployments.\n\n\n\n\n\n\nImportant\n\n\n\nThe results for the float16 1280x800 CRAFT model could not be obtained on our target device."
  },
  {
    "objectID": "posts/optimizing-text-detectors.html#conclusion",
    "href": "posts/optimizing-text-detectors.html#conclusion",
    "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST",
    "section": "Conclusion",
    "text": "Conclusion\nIn this post, we presented a comparative study between two text detection models - CRAFT and EAST. We went beyond their task-specific performance and considered various essential factors that one needs to consider when deploying these models. At this point, you might have felt the need to consider another important factor of these models - FPS information of the models on real-time videos. Please check out this repository to get a handle on how to approach that development."
  },
  {
    "objectID": "posts/optimizing-text-detectors.html#contribution",
    "href": "posts/optimizing-text-detectors.html#contribution",
    "title": "A Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST",
    "section": "Contribution",
    "text": "Contribution\nTulasi worked on the CRAFT model while Sayak worked on the EAST model. For the purpose of this post, Tulasi focused on gathering all the relevant information for doing the comparisons while Sayak focused on the writing part.\nThanks to Khanh LeViet from the TFLite team for reviewing the post."
  },
  {
    "objectID": "posts/quarto-migration.html",
    "href": "posts/quarto-migration.html",
    "title": "Another Quarto Migration Guide for fastpages Users",
    "section": "",
    "text": "For more than four years, I used fastpages for my personal site, sayak.dev, because it offered a really easy way to do blogging. When its creator, Hamel, posted about its deprecation in favor of Quarto, I was anxious. Migrations always make me anxious. But I still continued with fastpages anyway.\nBut entering into this year, I decided to finally switch to Quarto for apparently no specific reason. I think I just wanted a fresh look for my website but didn‚Äôt want something too fancy. Quarto provides a perfect balance between simplicity and visual aesthetics. So, I knew I would use Quarto eventually I migrate from fastpages.\nHamel provides an excellent Quarto migration guide for fastpages users here. However, I had to take care of a few additional things to make it all work and successfully migrate sayak.dev to Quarto. In this post, I want to provide a detailed account of what I did and some personal preferential bits in the hope that it will be beneficial for someone else. Let‚Äôs get started üí´\n\nBit 0: Go through the original migration guide\nThis post assumes that you‚Äôre here because you‚Äôre migrating your fastpages website to Quarto. So, it‚Äôs a must that you first read Hamel‚Äôs migration guide in detail.\n\n\nBit 1: Install nbdev from source\nWhile running the nbdev_migrate --path posts step, you might encounter compatibility problems. This is, luckily, easily mitigated by installing nbdev from source:\npip install git+https://github.com/fastai/nbdev\n\n\nBit 2: Use a separate repository for dev\nI found it it‚Äôs better and more convenient to use a separate repository while doing the initial developments related to the migration. For example, my website code is hosted at https://github.com/sayakpaul/portfolio/, but I maintained another repository during the initial development.\nThis especially comes in handy for setting up the GitHub Actions, previewing the site with GitHub Pages, etc. This way, you can also ensure that everything looks hunky-dory before you move the contents to the actual serving repository (‚Äúportfolio‚Äù in my case).\n\n\nBit 3: Connect with GitHub Actions and Pages\nMost of us (if not all) want to automate the website publishing process after a change is pushed to the serving repository. So, we should definitely set up a workflow that does this for us. Refer to the official Quarto documentation to use the recommended worflow file. It covers most use cases and it worked like a charm in my case. I didn‚Äôt have to touch a single thing in the workflow. Refer here for connecting your site with GitHub Pages.\n\n\nBit 4: Pay attention to branch names\nIf you used another repository as suggested in ‚ÄúBit 2‚Äù, be careful about the branch names when moving the contents over to the actual repository. You need to configure a repository branch name in the following places, for example:\n\nThe publishing worfkflow\nThe ‚Äú_quarto.yml‚Äù configuration\n\nThis is important to note because fastpages defaults to ‚Äúmaster‚Äù while recent GitHub repositories default to ‚Äúmain‚Äù.\n\n\nBit 5: Careful copying\n(Only applicable if you used another repository as per ‚ÄúBit 2‚Äù)\nWhen you‚Äôre satisfied with the migrated content, you may wish to copy over all the elements in the original repository. Some things I found to be useful to keep in mind while performing this step (assuming both the backup and original repositories are locally cloned):\n\nClear out the original repository contents, first: rm -rf * .gitignore .github. This will remove all the files and folders along with the .gitignore file. You can add any other hidden files to the mix as needed. But don‚Äôt accidentally delete the .git file.\nCopy over the contents from your backup repository: cp -r backup_repo/* original_repo/ && cp -r backup_repo/.github original_repo/. Finally, copy the .gitignore file: cp backup_repo/.gitignore original_repo/. You can copy any additional hidden file as needed, but not the .git file.\n\nI know that this step is slightly involved and can potentially be made simpler.\n\n\nBit 6: Configuring a custom domain\n(Only applicable if you‚Äôre serving from a custom domain)\nI struggled with this step a little. After setting up the CNAME on my repository here and configuring the GitHub Pages section as shown here, my site was not getting rendered at ‚Äúsayak.dev‚Äù, yielding 404 errors. After some Google searches, I stumbled upon this thread, and it solved the problem!\nAnd that‚Äôs it! I found the Quarto resources to be really self-sufficient and the migration process was way smoother than expected, thanks to the amazing resources."
  },
  {
    "objectID": "posts/mobiledet-optimization.html",
    "href": "posts/mobiledet-optimization.html",
    "title": "Optimizing MobileDet for Mobile Deployments",
    "section": "",
    "text": "This year researchers from the University of Wisconsin-Madison and Google published their work on MobileDet. MobileDet presents an architectural philosophy for designing object detectors specifically targeted toward running on mobile accelerators like DSP, EdgeTPU, and so on. MobileDet yields significant improvement over architectures MobileNetV2+SSDLite and MobileNetV3+SSDLite on the COCO object detection task with the same accelerated inference time. Long story cut short, if you are planning to use object detection models in mobile applications MobileDets may be an extremely good choice.\nOne fantastic thing about modern-day research is most of the time, the code and essential artifacts (like the trained models) are available publicly. MobileDet is no exception; the authors released their code and pre-trained models in TensorFlow Object Detection (TFOD) API. The model files come in three different variants -\nEach of these variants includes the pre-trained checkpoints, a TensorFlow Lite (TFLite) compatible model graph, a TFLite model file, a configuration file, and a graph proto. The models were pre-trained on the COCO dataset.\nIn this post, I am going to be revisiting the TFLite conversion from the pre-trained model checkpoints along with some of the non-trivial things that come up during the process. It is basically an extension of Khanh LeViet and my findings we shared over this GitHub thread.\nThe code discussed throughout this post is available here as a Colab Notebook."
  },
  {
    "objectID": "posts/mobiledet-optimization.html#why-yet-another-post-on-model-conversion",
    "href": "posts/mobiledet-optimization.html#why-yet-another-post-on-model-conversion",
    "title": "Optimizing MobileDet for Mobile Deployments",
    "section": "Why yet another post on model conversion?",
    "text": "Why yet another post on model conversion?\nFair question. After all, there are so many great examples and tutorials that show how to use the post-training quantization APIs in TFLite to perform the model conversion. MobileDet models in the TFOD API repository were trained in TensorFlow (TF) 1. If you ever wanted to use the latest TFLite converter to do the conversion, that may not be immediately approachable.\nBesides, there are certain caveats to the EdgeTPU and DSP variants. They come in two precision formats - uint8 and float32. The models in uint8 precision were trained using quantization aware training (QAT) while the float32 models were not. During QAT fake quantization nodes get inserted into a model‚Äôs computation graph. So, the models trained using QAT usually require some extra care during the TFLite conversion process as we‚Äôll see in a moment.\nIf we wanted to convert a single shot detector (SSD) based model to TFLite then we first need to generate a frozen graph first that is compatible with the TFLite operator set (as per these guides - TF1 and TF2). The TFOD API team provides stock scripts (TF1, TF2) for this. Both of these scripts add optimized postprocessing operations to the model graph. Now, these operations are not yet supported in int8 precision. So, if you ever wanted to convert these pre-trained checkpoints using full integer quantization, what would have been your approach?\nBy now, hopefully, I have been able to convince you that this post is not just about regular model conversion in TFLite. The situations we‚Äôll be going through over the next sections may be helpful for your production TFLite models as well."
  },
  {
    "objectID": "posts/mobiledet-optimization.html#the-hassle-free-conversions",
    "href": "posts/mobiledet-optimization.html#the-hassle-free-conversions",
    "title": "Optimizing MobileDet for Mobile Deployments",
    "section": "The hassle-free conversions",
    "text": "The hassle-free conversions\nBefore we build our way toward the fun stuff, let‚Äôs start with the conversions that won‚Äôt cost us a night‚Äôs sleep. Conversions based on dynamic-range and float16 quantization would come under this category.\n\n\n\n\n\n\nImportant\n\n\n\nThe EdgeTPU and DSP variants of MobileDet are meant to run on the respective hardware accelerators. These accelerators need a model to be in full integer precision. So converting the EdgeTPU and DSP variants with dynamic-range and float16 quantization does not have any practical usage.\n\n\nSo, for dynamic-range and float16 quantization based conversions, we will be using the CPU variant only. This variant is available here as ssd_mobiledet_cpu_coco. Once the model bundle is untar‚Äôd we get the following files -\n‚îú‚îÄ‚îÄ model.ckpt-400000.data-00000-of-00001\n‚îú‚îÄ‚îÄ model.ckpt-400000.index\n‚îú‚îÄ‚îÄ model.ckpt-400000.meta\n‚îú‚îÄ‚îÄ model.tflite\n‚îú‚îÄ‚îÄ pipeline.config\n‚îú‚îÄ‚îÄ tflite_graph.pb\n‚îî‚îÄ‚îÄ tflite_graph.pbtxt\nmodel.ckpt-* files are the pre-trained checkpoints on the COCO dataset. If you train a MobileDet object detection model on your own dataset, you will have your own model checkpoint files. The tflite_graph.pb file is a frozen inference graph that is compatible with the TFLite operator set, which was exported from the pre-trained model checkpoints. model.tflite file is a TFLite model that was converted from the tflite_graph.pb frozen graph.\nIn case if you ever train a MobileDet model on your dataset, here‚Äôs how you‚Äôd get the TFLite frozen graph file (based on this guide mentioned above) -\n$ PIPELINE_CONFIG=\"checkpoint_name/pipeline.config\"\n$ CKPT_PREFIX=\"checkpoint_name/model.ckpt-400000\"\n$ OUTPUT_DIR=\"tflite_graph\"\n \n$ python models/research/object_detection/export_tflite_ssd_graph.py \\\n   --pipeline_config_path=$PIPELINE_CONFIG \\\n   --trained_checkpoint_prefix=$CKPT_PREFIX \\\n   --output_directory=$OUTPUT_DIR \\\n   --add_postprocessing_op=true\nYou can see a fully worked out example in the Colab Notebook mentioned above. If everything goes well, then you should have the frozen graph file exported in OUTPUT_DIR. Let‚Äôs now proceed to the TFLite model conversion part.\nHere‚Äôs how the dynamic-range quantization would look like in TensorFlow 2 -\nconverter = tf.compat.v1.lite.TFLiteConverter.from_frozen_graph(\n    graph_def_file=model_to_be_quantized,\n    input_arrays=['normalized_input_image_tensor'],              \n    output_arrays=['TFLite_Detection_PostProcess',\n        'TFLite_Detection_PostProcess:1',\n        'TFLite_Detection_PostProcess:2',\n        'TFLite_Detection_PostProcess:3'],\n   input_shapes={'normalized_input_image_tensor': [1, 320, 320, 3]}\n)\nconverter.optimizations = [tf.lite.Optimize.DEFAULT]\ntflite_model = converter.convert()\nA note about some of the parameters and their values from the above code listing -\n\nmodel_to_be_quantized corresponds to the frozen graph file.\ninput_arrays and input_shapes are set accordingly with respect to the frozen graph file. As we can see in the figure below that these values have been set correctly.\n\noutput_arrays is set according to the instructions provided in this guide. Those operations represent four arrays: detection_boxes, detection_classes, detection_scores, and num_detections, usually a mandate for any object detector out there.\n\nThe rest of the parts in the code listing should be familiar to you if you already know about the typical post-training quantization process in TFLite. For float16 quantization, all the things would remain the same; we just need to add this line before calling convert() - converter.target_spec.supported_types = [tf.float16].\nThe dynamic-range quantized model is 4.3 MB in size and float16 one is 8.2 MB. Later, we will see how fast this model would run on actual mobile devices with and without different accelerators."
  },
  {
    "objectID": "posts/mobiledet-optimization.html#the-trickier-tflite-conversions-for-mobiledet",
    "href": "posts/mobiledet-optimization.html#the-trickier-tflite-conversions-for-mobiledet",
    "title": "Optimizing MobileDet for Mobile Deployments",
    "section": "The trickier TFLite conversions for MobileDet",
    "text": "The trickier TFLite conversions for MobileDet\nIn this section, we will be dealing with the full integer quantization for the three different variants of MobileDet. Full integer quantization is usually more involved than the other quantization formats supported by TFLite.\n\nRepresentative dataset\nOur first step toward doing full integer quantization is preparing a representative dataset. It is required to calibrate the activation ranges so that the quantized model is able to retain the original model performance as much as possible. For the purpose of this post, I sampled 100 images from the COCO training dataset (train2014 split). In my experience, 100 samples as the representative dataset have always been sufficient. I have hosted these images here in case you are interested to use them.\nThe following code listing denotes a generator function that produces a preprocessed image to the TFLite converter -\nrep_ds = tf.data.Dataset.list_files(\"train_samples/*.jpg\")\nHEIGHT, WIDTH = 320, 320\n \ndef representative_dataset_gen():\n   for image_path in rep_ds:\n       img = tf.io.read_file(image_path)\n       img = tf.io.decode_image(img, channels=3)\n       img = tf.image.convert_image_dtype(img, tf.float32)\n       resized_img = tf.image.resize(img, (HEIGHT, WIDTH))\n       resized_img = resized_img[tf.newaxis, :]\n       yield [resized_img]\nNote that these preprocessing steps should be in sync with the actual preprocessing steps that would apply before running inference with your TFLite model. In case if you are interested to know about more complex representative dataset generators you may find this notebook useful.\nAlso, note that dynamic-range and float16 quantization of the EdgeTPU and DSP variants don‚Äôt have much of practical usage. The next section is going to be solely about full integer quantization of these different variants and the nitty-gritty to take into consideration for the conversion process.\n\n\nDealing with fake quantization nodes during conversion\nThe figure below represents a portion of the uint8 EdgeTPU model computation graph. The nodes highlighted in red are inserted by the QAT mechanism. You would notice the same kind of nodes in the uint8 DSP model computation graph as well.\n\nNow, these nodes have some important implications that we need to consider during the conversion process -\n\nDuring QAT the activation ranges are already approximated i.e.¬†QAT resembles post-training quantization during training and adjusts the activation ranges accordingly. So, we don‚Äôt need to provide a representative dataset for a full integer quantization based conversion.\nThese fake nodes are generally in integer precision. So, setting an optimization option (converter.optimizations) might lead to inconsistencies.\nIn order to convert the uint8 models with full integer quantization, we need to set the input and output data type of the TFLite models to integer precision (typically uint8 or int8). As per this documentation, we also need to specify the quantized_input_stats parameter during the conversion process. This is needed in order for the converted TFLite model to map the quantized input values to real values. More details are available here.\n\nSo, how do we realize all of these in code?\nconverter = tf.compat.v1.lite.TFLiteConverter.from_frozen_graph(\n   graph_def_file=model_to_be_quantized,\n   input_arrays=['normalized_input_image_tensor'],\n   output_arrays=['TFLite_Detection_PostProcess',\n       'TFLite_Detection_PostProcess:1',\n       'TFLite_Detection_PostProcess:2',\n       'TFLite_Detection_PostProcess:3'],\n   input_shapes={'normalized_input_image_tensor': [1, 320, 320, 3]}\n)\nconverter.inference_input_type = tf.uint8\nconverter.quantized_input_stats = {\"normalized_input_image_tensor\": (128, 128)}\ntflite_model = converter.convert()\nIf you‚Äôre thinking this does not look all that gory compared to the above code listing - it does not have to be! The tooling should help you do these things seamlessly. But catching these details during your project development may not be trivial. Note that we don‚Äôt specify converter.inference_output_type. Hold your breath, we will come to this in a moment.\nAfter successful execution, we get two full integer quantized models - EdgeTPU one is 4.2 MB and the DSP one is 7.0 MB.\n\n\nInteger quantization for CPU variants and float32 precision models\nThe variants that don‚Äôt contain fake quantization nodes (CPU and all the models in float32 precision) have a relatively simpler conversion process. Recollect that the EdgeTPU and DSP variants come in two different precisions - uint8 and float32. For example, here‚Äôs how it would be for the float32 precision models -\nconverter.representative_dataset = representative_dataset_gen\nconverter.inference_input_type = tf.uint8\nconverter.optimizations = [tf.lite.Optimize.DEFAULT]\nNote that we are specifying a representative dataset here because the float32 precision models weren‚Äôt trained using QAT. For the CPU variant model, the lines of code would slightly change -\nconverter.inference_input_type = tf.uint8\nconverter.quantized_input_stats = {\"normalized_input_image_tensor\": (128, 128)}\nconverter.optimizations = [tf.lite.Optimize.DEFAULT]\nHonestly, I found this configuration by trial and error. I observed that if I specify a representative dataset then it hurts the predictions of the converted model. Also, I found out that specifying converter.quantized_input_stats helped improve the predictions of the converted model.\nWe don‚Äôt specify converter.inference_output_type in this case as well. Let‚Äôs get to it now.\n\n\nDealing with non-integer postprocessing ops during conversion\nRemember that frozen graph exporter scripts provided by the TFOD API team add optimized postprocessing operations to the graph. These operations are not supported in integer precision yet. So, even if you wanted to specify converter.inference_output_type as tf.uint8 you‚Äôll likely get the following error -\nRuntimeError: Unsupported output type UINT8 for output tensor 'TFLite_Detection_PostProcess' of type FLOAT32.\nThis is why we did not set the converter.inference_output_type parameter.\nThis should resolve all the problems you may run into if you ever wanted to convert the MobileDet models offered by the TFOD API team. In the last two sections, we‚Äôll see these converted models in action and how fast they can perform on respective hardware accelerators."
  },
  {
    "objectID": "posts/mobiledet-optimization.html#show-me-some-results",
    "href": "posts/mobiledet-optimization.html#show-me-some-results",
    "title": "Optimizing MobileDet for Mobile Deployments",
    "section": "Show me some results",
    "text": "Show me some results\nFor the CPU variant model, its float16 quantized TFLite provided decent results -\n\nOn Colab, the inference time is about 92.36 ms for this particular model. I experimented with different threshold values for filtering out the weak predictions and a threshold of 0.3 yielded the best results. These results are pretty consistent across the several different models we talked about.\nA major point to note here for the EdgeTPU and DSP variants, their converted counterparts would be much slower on Colab since they were specifically optimized for different hardware accelerators.\nYou are encouraged to play with the different converted models using the Colab Notebook mentioned above and see these results for yourself."
  },
  {
    "objectID": "posts/mobiledet-optimization.html#model-benchmarks",
    "href": "posts/mobiledet-optimization.html#model-benchmarks",
    "title": "Optimizing MobileDet for Mobile Deployments",
    "section": "Model benchmarks",
    "text": "Model benchmarks\nIn this section, we‚Äôll address the question - ‚ÄúSo, how do I choose one among these many models?‚Äù Well, you could manually try them all out and see which performs the best on the runtime of your choice. But a more practical approach to this would be to first benchmark these models on a set of devices using the TFLite Benchmark Tool and then decide accordingly.\nThe following table provides a comprehensive summary of the important statistics about the runtime of different TFLite MobileDet models. These results were generated using the TFLite Benchmark Tool mentioned above.\n\n\n* Device used - Pixel 4 (Inference timings are reported in milliseconds) ** As reported here\n\nWe can see that with the proper hardware accelerators, the DSP EdgeTPU variants can really shine. For the CPU variant, on a GPU accelerated runtime the float16 quantized TFLite model can bring in additional speed boosts.\nA catch here is Pixel devices don‚Äôt allow third-party applications to use the Hexagon DSP therefore even if we instruct the Benchmark Tool to make use of that the model would fall back to the CPU for execution. This is why for fair benchmarking results for the DSP variants we should consider running the Benchmark Tool on a device (such as Samsung Galaxy S9+) that has Hexagon DSP and also allows third-party applications to use it.\n\n\n* Device used - Samsung Galaxy S9+ (Inference timings are reported in milliseconds)\n\n\n\n\n\n\n\nNote\n\n\n\nTo train a custom MobileDet-based object detector you can refer to these notebooks."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Flavors of attention in modern diffusion models\n\n\nDifferent forms of attention mechanisms, used in modern diffusion models.\n\n\n\n\n\nFeb 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nFlavors of attention in modern diffusion models\n\n\nDifferent forms of attention mechanisms, used in modern diffusion models.\n\n\n\n\n\nFeb 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nStreamlining PyPI Releases: A Case Study with üß® Diffusers\n\n\nLearnings from streamlining the PyPI releases of üß® Diffusers.\n\n\n\n\n\nMar 15, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nAnother Quarto Migration Guide for fastpages Users\n\n\nSome tidbits of migrating from fastpages to Quarto.\n\n\n\n\n\nJan 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nPracticing ML in a Non-ML Job\n\n\nThoughts on learning and exercising ML skills.\n\n\n\n\n\nMay 27, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nFirst Steps in GSoC\n\n\nSharing my perspective on two primary questions related to Google Summer of Code.\n\n\n\n\n\nMar 13, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nPublishing ConvNeXt Models on TensorFlow Hub\n\n\nConverting PyTorch ConvNeXt models to TensorFlow and publishing them on TF-Hub.\n\n\n\n\n\nFeb 3, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nDistributed Training in TensorFlow with AI Platform & Docker\n\n\nTraining a model using distributed training with AI Platform and Docker.\n\n\n\n\n\nApr 6, 2021\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding and Installing OpenCV 4.5.0 on an M1 Mac\n\n\nThis post shows how to build and install OpenCV 4.5.0 on a MacBook Pro that comes with an M1 chip.\n\n\n\n\n\nJan 1, 2021\n\n\n\n\n\n\n\n\n\n\n\n\nA Battle of Text Detectors for Mobile Deployments: CRAFT vs.¬†EAST\n\n\nThis post compares two Deep Learning-based text detectors CRAFT and EAST with respect to deployment-specific requirements.\n\n\n\n\n\nNov 27, 2020\n\n\nSayak Paul, Tulasi Ram Laghumavarapu\n\n\n\n\n\n\n\n\n\n\n\n\nOptimizing MobileDet for Mobile Deployments\n\n\nLearn about the criticalities of effectively optimizing MobileDet object detectors for mobile deployments.\n\n\n\n\n\nSep 29, 2020\n\n\n\n\n\n\n\n\n\n\n\n\nThe Maker Philosophy with ML APIs\n\n\nPractising being a maker with Google Cloud Platform‚Äôs ML APIs.\n\n\n\n\n\nSep 25, 2020\n\n\n\n\n\n\n\n\n\n\n\n\nA few favorite recipes in computer vision & deep learning\n\n\nThis blog post enlists a few of my favorite recipes in deep learning in the context of computer vision (as of August 2020).\n\n\n\n\n\nAug 2, 2020\n\n\n\n\n\n\n\n\n\n\n\n\nUsing TensorRT for accelerated deep learning inference\n\n\nAccelerating inference of TensorFlow models using TensorRT.\n\n\n\n\n\nJul 1, 2020\n\n\n\n\n\n\n\n\n\n\n\n\nDifferent data augmentation recipes in tf.keras for image classification\n\n\nLearn about different ways of doing data augmentation when training an image classifier in tf.keras.\n\n\n\n\n\nMay 10, 2020\n\n\n\n\n\n\n\n\n\n\n\n\nSharing your work online effectively\n\n\nA few tips on sharing your work online effectively.\n\n\n\n\n\nApr 20, 2020\n\n\n\n\n\n\n\n\n\n\n\n\nEmbedding an image preprocessing function in a tf.keras model\n\n\nLearn how to embed an image preprocessing function in a tf.keras model.\n\n\n\n\n\nApr 13, 2020\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sayak Paul",
    "section": "",
    "text": "Hi there üëã I am Sayak Paul (‡¶∏‡¶æ‡ßü‡¶ï ‡¶™‡¶æ‡¶≤). I work on üß® diffusion models at Hugging Face. Know more about me from here. I maintain a Google Doc answering some FAQs at length. You can check it out here. \nMy external articles and other publishing engagements are listed here. Decks from my speaking engagements are listed here. A detailed account of the things that are not directly available from the top navbar (interviews, talks etc.) can be found here.\nThe structure of this website is inspired by Omar‚Äôs site. \n\nNews\n\nNew work on few-step sampling of diffusion models SANA-Sprint: One-Step Diffusion with Continuous-Time Consistency Distillation with NVIDIA (accepted to ICCV‚Äô25).\nNew work: From Reflection to Perfection: Scaling Inference-Time Optimization for Text-to-Image Diffusion Models via Reflection Tuning with Le Zhuo, Liangbing Zhao, and others (accepted to ICCV‚Äô25).\nNew work (CVPR‚Äô25): Exploring the Deep Fusion of Large Language Models and Diffusion Transformers for Text-to-Image Synthesis with Bingda Tang, Boyang Zheng, Xichen Pan, and Saining Xie.\nNew work: Fine-Grained Perturbation Guidance via Attention Head Selection with Donghoon Ahn et. al.\nGave an invited talk at Stanford (CS25) about DiTs: Transformers in Diffusion Models for Image Generation and Beyond (slides and recording).\n\nTo know more about my projects, please refer to my GitHub profile. For an up-to-date list of my publications, refer to my Google Scholar page.\nApart from the blogs here, I try to contribute to other platforms in the form of writing. Please refer here for more details."
  },
  {
    "objectID": "posts/sharing-work.html",
    "href": "posts/sharing-work.html",
    "title": "Sharing your work online effectively",
    "section": "",
    "text": "Well, you have put a lot of blood and sweat into writing your latest blog post on Machine Learning. Don‚Äôt let your struggle go in vain and let the world know about it. Sharing your blog posts across different channels not only gives you exposure but also may get you tremendous feedback on your work. In my personal experience, the feedback has been super useful for me to improve myself not only as a writer but also as a communicator. There can be times you might have missed out on a super important detail, or you might have unknowingly introduced a snazzy bug in the code listings of your blog ‚Äì those things could have been caught in the process of feedback interchange.\nIn this short article, I am going to enlist a few different ways to share your work and get feedback. Note your work can be anything starting from a crucial GitHub PR, to a weekend project. Although the following platforms and communities are mostly limited to Machine Learning, I hope this guide will be useful for tech bloggers in general."
  },
  {
    "objectID": "posts/sharing-work.html#sharing-on-platformscommunities",
    "href": "posts/sharing-work.html#sharing-on-platformscommunities",
    "title": "Sharing your work online effectively",
    "section": "Sharing on platforms/communities",
    "text": "Sharing on platforms/communities\nBefore I start the sharing process, I generally create a Google Doc to effectively keep track of where I am sharing my work. This essentially acts as a checklist for all the places I want to share my work on. Here‚Äôs the template I follow for creating the Google Doc -\n\nLink to where the work has been posted.\nBrief description of the work.\nPost table:\n\n\nI generally keep the description to a maximum of 280 characters so that I can use it on Twitter as well.\nNow, turning to the platforms and communities, here are some recommendations (in no particular order): - HackerNews (https://news.ycombinator.com/newest) - Made With ML (https://madewithml.com/) - Reddit - r/MachineLearning - r/MachinesLearn - r/learnmachinelearning - r/deeplearning - Twitter - Facebook - AIDL - Montreal AI - Deep Learning - Fast.ai Forum (https://forums.fast.ai/) - LinkedIn - Google Groups (depends on the framework used in the work) - discuss@tensorflow.org - tflite@tensorflow.org - tfjs@tensorflow.org - tfx@tensorflow.org\nWhile sharing my work, I find it to be important to always attach a brief description. Additionally, if your work is related to implementing research work, you should definitely include it on Papers with Code."
  },
  {
    "objectID": "posts/sharing-work.html#sharing-to-aid-discussions",
    "href": "posts/sharing-work.html#sharing-to-aid-discussions",
    "title": "Sharing your work online effectively",
    "section": "Sharing to aid discussions",
    "text": "Sharing to aid discussions\nYou might be active on online forums like Quora, StackOverflow, and so on. While participating in a discussion in those forums you can make effective use of your work if it is relevant. In these cases, the approach is to not just supply a link to your work, but also to first write about any important pointers relevant to the discussion first, and then supply the link to your work to better aid it. Let‚Äôs say there‚Äôs a discussion going on the topic of ‚ÄúWhat is Weight Initialization in Neural Nets?‚Äù Here‚Äôs how I would approach my comment:\n\nA neural net can be viewed as a function with learnable parameters and those parameters are often referred to as weights and biases. Now, while starting the training of neural nets these parameters (typically the weights) are initialized in a number of different ways - sometimes, using constant values like 0‚Äôs and 1‚Äôs, sometimes with values sampled from some distribution (typically a uniform distribution or normal distribution), sometimes with other sophisticated schemes like Xavier Initialization. The performance of a neural net depends a lot on how its parameters are initialized when it is starting to train. Moreover, if we initialize it randomly for each run, it‚Äôs bound to be non-reproducible (almost) and even not-so-performant too. On the other hand, if we initialize it with constant values, it might take way too long to converge. With that, we also eliminate the beauty of randomness which in turn gives a neural net the power to reach covergence quicker using gradient-based learning. We clearly need a better way to initialize it. Careful initialization of weights helps us to train them better. To know more, please follow this article of mine.\n\nWell, that‚Äôs it for now. I hope it proves to be useful for you. Please provide any suggestions you may have via the comments. I am thankful to Alessio of FloydHub for sharing these tips with me."
  },
  {
    "objectID": "posts/tftrt-optimization.html",
    "href": "posts/tftrt-optimization.html",
    "title": "Using TensorRT for accelerated deep learning inference",
    "section": "",
    "text": "If you see the way deep learning research has progressed over the years, it has always been guided by the need of the hour. If I were to develop a chronology out of it, it would be something like - train better model -&gt; train them faster -&gt; get them good at generalizing well, and so on. With a stern increase in the demand for using deep learning more as just another technology stack, there could not have been a better time to think about how do we make our models infer faster. In this post, we are going to see how to use TensorRT to perform accelerated inference with TensorFlow (2) models. After all, making predictions with deep learning models is what makes you real üí∞ and we would want to make sure that our bucks burned judiciously.\n\nmobilenet_v2 = tf.keras.applications.MobileNetV2(weights='imagenet')\nmobilenet_v2.save('mobilenet_v2')\n\nDownloading data from https://storage.googleapis.com/tensorflow/keras-applications/mobilenet_v2/mobilenet_v2_weights_tf_dim_ordering_tf_kernels_1.0_224.h5\n14540800/14536120 [==============================] - 0s 0us/step\nWARNING:tensorflow:From /usr/local/lib/python3.6/dist-packages/tensorflow/python/ops/resource_variable_ops.py:1817: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version.\nInstructions for updating:\nIf using Keras pass *_constraint arguments to layers.\nINFO:tensorflow:Assets written to: mobilenet_v2/assets\n\n\nHere, mobilenet_v2 is a directory and when you pass a directory to the save function, it serializes the model in the TensorFlow SavedModel format. This format makes it easier for us to be able to use it on different platforms - be it on GCP‚Äôs AI Platform, be it on TensorFlow JS, be it on TensorFlow Serving, and so on.\nNow, there are some basic preprocessing steps to be followed before we can actually feed an image to this model -\n\n# Prepare the image for prediction\nimg = tf.keras.preprocessing.image.load_img('elephant.jpg', target_size=(224, 224))\nx = tf.keras.preprocessing.image.img_to_array(img)\nx = np.expand_dims(x, axis=0)\nx = tf.keras.applications.mobilenet_v2.preprocess_input(x)\n\nHere‚Äôs how elephant.jpg looks like in case if anyone‚Äôs curious -\n\n\n\n\n\n\n\n\n\nNow, running the prediction and decoding it is just a matter of two lines of code -\n\n# Run inference\npreds = mobilenet_v2.predict(x)\nprint('Predicted:', tf.keras.applications.mobilenet_v2.decode_predictions(preds, top=3)[0])\n\nDownloading data from https://storage.googleapis.com/download.tensorflow.org/data/imagenet_class_index.json\n40960/35363 [==================================] - 0s 0us/step\nPredicted: [('n02504013', 'Indian_elephant', 0.70024925), ('n01871265', 'tusker', 0.2549572), ('n02504458', 'African_elephant', 0.0033761878)]\n\n\nTo find out how much time does this model take to predict a given image? Let‚Äôs write a short utility function to handle that -\n\ndef time_my_model(model, data):\n    times = []\n    for i in range(20):\n        start_time = time.time()\n        one_prediction = model.predict(data)\n        delta = (time.time() - start_time)\n        times.append(delta)\n    mean_delta = np.array(times).mean()\n    fps = 1 / mean_delta\n    print('average(sec):{:.2f},fps:{:.2f}'.format(mean_delta, fps))\n\nIf we run time_my_model fives times the output would look like so -\n\n\naverage(sec):0.06,fps:15.48\naverage(sec):0.03,fps:32.26\naverage(sec):0.03,fps:32.48\naverage(sec):0.03,fps:31.14\naverage(sec):0.03,fps:31.67\n\n\nCan we further optimize this? We will start the next section with this question.\n\nOptimizing the pre-trained image classification model\nNote that explaining the different means of optimizing a deep learning model is out of the scop for this post. If you are interested, the following posts are great starting points -\n\nHigh performance inference with TensorRT Integration\nOptimizing TensorFlow Models for Serving\n\nLet‚Äôs now introduce the big elephant in the room - TensorRT. TensorRT is an SDK by NVIDIA for performing accelerated deep learning inference. It utilizes Tensor Cores of an NVIDIA GPU (for example V100, P4, etc.) and performs a number of model optimization steps for including parameter quantization, constant folding, model pruning, layer fusion, etc. You can know more about this SDK from here.\nNote that TensorRT will only be able to achieve acceleration when it‚Äôs used on supported hardware. For more on this, check out the aforementioned link.\nOptimizing the MobileNetV2 model is a three-step process -\n\nSetting up the optimization configuration -\n\nparams = trt.DEFAULT_TRT_CONVERSION_PARAMS._replace(\n    precision_mode='FP16',\n    is_dynamic_op=True)\nWe use the precision_mode argument to specify the numerical precision of the model parameters we would want. In this case it is FP16 (float16). is_dynamic_op argument is set to True so that the shapes would be determined during runtime. Onto the next step.\n(`trt` is aliased as `from tensorflow.python.compiler.tensorrt import trt_convert as trt`.)\n\nPerforming the model conversion for optimization -\nAs the headline suggests, in this step we actually perform the conversion with the configurations we specified in the previous step to optimize our model. python   converter = trt.TrtGraphConverterV2(       input_saved_model_dir='mobilenet_v2',       conversion_params=params)   converter.convert() For the conversion to take place, we are supplying the pre-trained MobileNetV2 model in the SavedModel format. It‚Äôs really nice to see how this format comes to unify different platforms.\nSerializing the optimized model -\nSerializing this optimized model is similar to how we did it for the pre-trained model - python   saved_model_dir_trt = 'mobilenet_v2.trt'   converter.save(saved_model_dir_trt)\n\nNow, how good is this new variant of the model? How accurate will it be? How much faster will it be? We will find those out in a moment. Before that let‚Äôs see how to run inference with this optimized model in the next section.\n\n\n\n\n\n\nImportant\n\n\n\nThe above code snippet won‚Äôt work in Colab or with any TensorFlow version that doesn‚Äôt ship a correctly compiled TensorRT (discussion). Therefore, it‚Äôs recommended to use an NVIDIA Docker container for this purpose. This resource can be useful in this regard.\n\n\n\n\nRunning inference with the optimized model\nTensorFlow 2.x provides a convenient function tf.saved_model.load to load the models saved in SavedModel. We are only interested in performing inference with the model so we will load the respective signature from the model as a concrete function -\n\n# Load the particular signature from the TRT graph\nroot = tf.saved_model.load(saved_model_dir_trt)\nconcrete_func = root.signatures['serving_default']\n\nYou can inspect the structure of this function by running concrete_func.structured_outputs and the output would be -\n\n\n{'predictions': TensorSpec(shape=(None, 1000), dtype=tf.float32, name='predictions')}\n\n\nAs we would expect, this function will yield a 1000-d vector which is nothing but probabilities distributed across the 1000 different classes of the ImageNet dataset. Also note the key of the above dictionary, it might not be ‚ÄòLogits‚Äô always.\nNow, to be able to run the inference and decode them in a human-interpretable way, we first need to get the ImageNet dataset labels -\n\n# Gather the ImageNet labels first and prepare them\nlabels_path = tf.keras.utils.get_file('ImageNetLabels.txt', 'https://storage.googleapis.com/download.tensorflow.org/data/ImageNetLabels.txt')\nimagenet_labels = np.array(open(labels_path).read().splitlines())\n\nTime for performing the inference -\n\n# Perform inference\nlabeling = concrete_func(tf.constant(x.astype('float32')))\nactivations = tf.nn.softmax(labeling['predictions'])\nimagenet_labels[np.argsort(activations)[0,::-1][:5]+1]\n\narray(['Indian elephant', 'tusker', 'African elephant', 'bull mastiff',\n       'Great Dane'], dtype='&lt;U30')\n\n\nLooks like our optimized model got it right!\nWhile parsing the predictions, we would need to put focus on the key in this case which is ‚Äòpredictions‚Äô.\n\n\nBattle of performance\nLet‚Äôs first recall where we were with our pre-trained MobileNetV2 -\naverage(sec):0.03,fps:37.22\naverage(sec):0.03,fps:36.54\naverage(sec):0.03,fps:36.54\naverage(sec):0.03,fps:38.93\naverage(sec):0.03,fps:37.24\nNow, to time the performance of our optimized model, we will need to make little adjustments to the utility function we previously wrote. This is mainly because now, we will now be using a concrete function which takes a tf.constant.\n\ndef time_trt_model():\n    image_input = tf.constant(x.astype('float32'))\n    times = []\n    for i in range(20):\n        start_time = time.time()\n        one_prediction = concrete_func(input_1=image_input)\n        delta = (time.time() - start_time)\n        times.append(delta)\n    mean_delta = np.array(times).mean()\n    fps = 1 / mean_delta\n    print('average(sec):{:.2f},fps:{:.2f}'.format(mean_delta, fps))\n\nFor convenience, here‚Äôs our x -\nimg = tf.keras.preprocessing.image.load_img('elephant.jpg', target_size=(224, 224))\nx = tf.keras.preprocessing.image.img_to_array(img)\nx = np.expand_dims(x, axis=0)\nx = tf.keras.applications.mobilenet_v2.preprocess_input(x)\nLet‚Äôs now run time_trt_model() for five times -\n\n\naverage(sec):0.00,fps:227.01\naverage(sec):0.00,fps:279.10\naverage(sec):0.00,fps:269.89\naverage(sec):0.00,fps:277.14\naverage(sec):0.00,fps:219.98\n\n\nThat‚Äôs quite a bit of improvement, isn‚Äôt it? Note that you may observe slower inference in your first call to time_trt_model(). It may happen because of the additional time a GPU takes to set itself up. When running comparisons like this, it‚Äôs a good practice to first warm up the base hardware by running a few test iterations on it and then run the actual iterations for comparison. Depending on the GPU you‚Äôre using, these numbers can vary (these experiments were performed a Tesla P100).\nTalking about the memory footprints of both the models, for the pre-trained model we have -\n\n# Size of the model files\n!du --all -h mobilenet_v2\n\n96K mobilenet_v2/variables/variables.data-00000-of-00002\n14M mobilenet_v2/variables/variables.data-00001-of-00002\n20K mobilenet_v2/variables/variables.index\n14M mobilenet_v2/variables\n3.9M    mobilenet_v2/saved_model.pb\n4.0K    mobilenet_v2/assets\n18M mobilenet_v2\n\n\nWe have a total of 18 MB here. For the optimized model, we have -\n\n!du --all -h mobilenet_v2.trt\n\n96K mobilenet_v2.trt/variables/variables.data-00000-of-00002\n14M mobilenet_v2.trt/variables/variables.data-00001-of-00002\n20K mobilenet_v2.trt/variables/variables.index\n14M mobilenet_v2.trt/variables\n31M mobilenet_v2.trt/saved_model.pb\n4.0K    mobilenet_v2.trt/assets\n45M mobilenet_v2.trt\n\n\nWoah! The size has increased in this case! This is because the computational graph of our optimized model has been changed. However, the size of the parameters (mobilenet_v2/variables and mobilenet_v2.trt/variables) of both models is the same.\nIn real-life situations, as a machine learning practitioner, you will often have to make trade-offs between memory footprints, performance both in terms of accuracy and inference time. So having the knowledge of employing the right tools at the right moment will help you a long way. So, if you are looking for reducing the memory footprint of the model as well as accelerating the inference time, TensorFlow Lite is a good choice. In the bonus section of the post, we are going to discuss it.\n\n\n\n\n\n\nImportant\n\n\n\nTensorFlow has now introduced a tf.experimental.tensorrt.Converter API with better support for TensorRT.\n\n\n\n\nUsing TensorRT on your custom models\nThis section is for you to pick up. It will be a nice weekend project to train a simple model on a custom dataset and compare the performances as we saw in this post. Additionally, it will be interesting to compare different evaluation metrics like accuracy, precision, and recall for the different models (a custom trained mode, its optimized variants). We barely scratched the surface of TensorRT in this post. You are encouraged to experiment with the different arguments that come with the functions we saw in the post and figure out what works the best for your use-case. If your use-case involves embedded devices and mobile phones then TensorFlow Lite will be another great framework for you to explore."
  },
  {
    "objectID": "posts/ml-practice.html",
    "href": "posts/ml-practice.html",
    "title": "Practicing ML in a Non-ML Job",
    "section": "",
    "text": "Many people who aspire to become Machine Learning (ML) practitioners find it particularly difficult to continue to hone relevant skills when they pursue a job that does not involve even a tiny bit of ML. So, if you‚Äôre serious about choosing ML as a potential career option, it‚Äôs important to ensure you continue to practise what you‚Äôre learning along the way. Otherwise, there‚Äôd likely be nothing for a recruiter to trust in your candidature which, in turn, minimizes your chances of landing the ML job you always wanted.\nI myself am not an exception to this. Back in 2017, when I was working at Tata Consultancy Services Limited (TCS), I didn‚Äôt get any assignments involving ML expertise. But I tried to utilize my off-work hours in a way that helped me improve my ML-specific knowledge as well as strengthen my candidature.\nSo, in this post, I‚Äôll share what I did during those days in the hope of providing some meaningful ways for navigation.\nDisclaimer: The opinions stated in this post are solely mine and they are not meant to demean anyone else‚Äôs opinions about the same topic."
  },
  {
    "objectID": "posts/ml-practice.html#assumptions",
    "href": "posts/ml-practice.html#assumptions",
    "title": "Practicing ML in a Non-ML Job",
    "section": "Assumptions",
    "text": "Assumptions\nThe post is best-suited for professionals that have prior experience in coding (preferably in Python) and know their way around the fundamentals of ML. If you‚Äôre an absolute beginner then I recommend picking up a book (an example) or a course (an example) to get started. Also, if you haven‚Äôt yet picked up an ML framework (Scikit-Learn, PyTorch, TensorFlow, JAX, etc.), then I highly recommend picking one up."
  },
  {
    "objectID": "posts/ml-practice.html#solace-in-uncertainty",
    "href": "posts/ml-practice.html#solace-in-uncertainty",
    "title": "Practicing ML in a Non-ML Job",
    "section": "Solace in Uncertainty",
    "text": "Solace in Uncertainty\nSet your objectives straight. Ask yourself if you‚Äôre absolutely certain about wanting to pursue a career in ML. If so, then are you willing to make the adjustments necessary to attain that at any cost? Although these questions are not specific to the purposes of this post, they help set a mindset to push through uncertain times.\nI was hell-bent on taking up a career in ML that helped me to work on myself in those extra hours after work. It didn‚Äôt feel like I‚Äôm being forced into doing this. I thoroughly enjoyed the process and I trusted it. There are things I still enjoy doing like, reading a new paper, learning about a new concept, implementing it, etc."
  },
  {
    "objectID": "posts/ml-practice.html#overwhelm-and-courage-to-learn",
    "href": "posts/ml-practice.html#overwhelm-and-courage-to-learn",
    "title": "Practicing ML in a Non-ML Job",
    "section": "Overwhelm and Courage to Learn",
    "text": "Overwhelm and Courage to Learn\nFeeling overwhelmed especially in the ML domain is common given how vast the field is and how rapidly it is evolving regularly. I see this positively because I know that there are things I don‚Äôt yet know and I use it as a learning opportunity to improve my knowledge.\nOne might wonder, do I learn each and everything that comes out? That‚Äôs impossible and likely, isn‚Äôt very helpful. So, I like to pick up something from the vault of things that genuinely interest me in ML and start digging deeper. I find it incredibly helpful in boosting my confidence. I also figured that the more I did this, the better I was able to develop a general understanding of a broad number of relevant things.\nIn a nutshell, treating the feeling of ‚Äúoverwhelm‚Äù as a learning opportunity has been quite helpful for me."
  },
  {
    "objectID": "posts/ml-practice.html#learn-apply-demo-repeat",
    "href": "posts/ml-practice.html#learn-apply-demo-repeat",
    "title": "Practicing ML in a Non-ML Job",
    "section": "Learn, Apply, (Demo), Repeat",
    "text": "Learn, Apply, (Demo), Repeat\nLearning is not enough. You need to be able to develop evidence that shows you can apply what you‚Äôve learned successfully. I highly recommend reading this interview with Emil Wallner who‚Äôs an ‚Äúinternet-taught‚Äù ML Researcher working as a resident at Google.\nBelow, I discuss a few things you can do to exercise your ML learnings.\n\nKaggle\nKaggle is arguably one of the best platforms to develop skills for data preprocessing and applying ML in creative ways to solve unique problems. So, pick an interesting dataset or a competition just for learning purposes. Putting the competitive mindset aside, during my initial years it really helped me to develop a mindset of always learning to facilitate self-improvement. If you commit to it hard enough, you will have developed a bunch of useful skills. Over time, you‚Äôll definitely get better.\nKeeping an open mind for learning is important here because expectations of outcomes can quickly derail you. Also, remember that the rate of improvement is not the same for everyone. So, it‚Äôs better to just do things that are within your control (for example, learning something), and consistently get better at those.\n\n\nPapers / Concepts\nReading research papers is a common undertaking in ML. It can be rewarding to summarize, implement, and blog about a paper that is impactful and tackles interesting problems. Extending on this theme, you have a number of options:\n\nYou can summarize a paper in your own words and publish it on platforms like Medium or even on your own blog. It‚Äôs also important to get feedback on your work. So, feel free to share your work on Social Media as well as let the authors of the actual paper know about your work. A paper summary is supposed to be a reflection of how you perceived the paper. So, if you have criticisms of a paper, do include those with solid reasoning. If you‚Äôre looking for an example, definitely check out Aakash Kumar Nain‚Äôs paper summaries.\nPicking a paper could be a non-trivial work especially when there‚Äôs always a flood of papers on arXiv. I usually follow the blogs of research labs at Google, Meta, AI2, BAIR, etc., to keep myself up-to-date about the work I care about. There‚Äôs a good chance you‚Äôll find your niche there. Following the works of the most accomplished researchers from my favorite domains is another practice I incorporate.\nIn this regard, I highly recommend the following two books that actively cite examples of relevant research papers and also implement them in ways that are practically beneficial: Deep Learning for Coders with fastai and PyTorch by Jeremy Howard and Sylvain Gugger, Natural Language Processing with Transformers by Lewis Tunstall, Leandro von Werra, and Thomas Wolf. For developing a general understanding of different areas in ML, I recommend the articles on Distill Pub. \nNowadays, a majority of ML papers come with official open-source implementations in the interest of reproducibility. But some don‚Äôt. Regardless of either, it‚Äôs a good exercise to try to implement the novel bits of a paper. The timmlibary is a great example of how paper reimplementations should be structured. \nBlogging has easily become one of the most effective ways to communicate your understanding of something. This does not need to be just tied to papers, though. You can always pick up an interesting concept and blog about it. Many ML stalwarts keep pressing on why you should blog and here is one such example: Why you (yes, you) should blog by Rachel Thomas.\n\nYou can also consider making videos on papers, concepts, and so on. If you haven‚Äôt already, then definitely get to know Yannic Kilcher who has revolutionized the way forward in this theme.\n\n\nOpen-source Contributions\nFrom my personal experience, I can confirm that making open-source contributions is one of the most useful ways to stay involved in the domain. All the popular ML Python libraries (Scikit-Learn, PyTorch, TensorFlow, Keras, JAX, Hugging Face Transformers, etc.) are open-source and that provides even more opportunities to learn and grow.\nI have a separate presentation on this topic but here, I provide my perspectives for context:\n\nWhen you‚Äôre contributing to a well-maintained open-source library for the first time there‚Äôs a high chance that you‚Äôll learn a few things other than just ML. These include writing unit tests, setting up the local development environment, library building tools, etc. This way, you get first-hand exposure to how software engineering is approached in the ML domain in general.\nSo, not only do you get to contribute to your favorite open-source library (which is an inexplicable feeling anyway), but you also get to learn skills that are practically quite demanding. Beyond these, you get a chance to interact with experts and get their feedback to improve your work. Additionally, you get to collect objective evidence of your skills - coding, thorough understanding of a critical component and the library, building a library, etc. - all of which are noteworthy.\nNote that you‚Äôre not alone if you‚Äôre feeling lost when you‚Äôre just starting to contribute to an open-source library. It happens to most. But when you put your mind toward making your contribution anyway, you get to get better in the process. \nIf you feel you‚Äôre not ready yet to make contributions, working on your own open-source projects is another promising avenue to pursue. Take Andrej Karpathy‚Äôs miniGPT project as an example. Besides being an amazing educational resource for learning about the GPT model, it serves as a great reference for implementing many of the foundational blocks of Transformer-based architectures.\nIf you‚Äôre looking for open-source project ideas then my presentation on this topic might be helpful.\n\nNow that we‚Äôve looked into different ways of being engaged with our independent ML practice, let us take examples of two individuals from the ML community who have followed similar paths in this regard."
  },
  {
    "objectID": "posts/ml-practice.html#references-from-the-community",
    "href": "posts/ml-practice.html#references-from-the-community",
    "title": "Practicing ML in a Non-ML Job",
    "section": "References from the Community",
    "text": "References from the Community\nMatt (ML Engineer at Hugging Face) says -\n\n[‚Ä¶] I did a few small projects to get familiar with Keras and then tried reimplementing papers or building examples to contribute to places like keras-contrib or keras.io.\n\n\nChansung (ML-GDE and MLOps Engineer) says -\n\n[‚Ä¶] Anyways, I actually didn‚Äôt plan what to do for the next few years. I just have followed my interests and the joy to participate as a community member. And whenever I make any moves, I found other exciting events are waiting for me. These days, I am really enjoying creating open-source projects and applied ML products, and collaborative projects with you as well.\n\n\nBoth of them continue to push their boundaries for self-improvement and are exceptional at what they do."
  },
  {
    "objectID": "posts/ml-practice.html#finishing-up",
    "href": "posts/ml-practice.html#finishing-up",
    "title": "Practicing ML in a Non-ML Job",
    "section": "Finishing Up",
    "text": "Finishing Up\nThe pursuit of betterment doesn‚Äôt stop after you land the job you were aspiring for. I continue to benefit from my open-source engagements even after professionally working in the area for some time now. I hope you‚Äôre able to take forward the pointers discussed in the post and experiment with them. If you have any suggestions for other interesting ways for independent ML practice please let me know."
  },
  {
    "objectID": "posts/ml-practice.html#acknowledgments",
    "href": "posts/ml-practice.html#acknowledgments",
    "title": "Practicing ML in a Non-ML Job",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nI want to thank all my wonderful collaborators and mentors who continue to inspire me to be better. I am also thankful to Neerajan Saha for proofreading this post."
  },
  {
    "objectID": "posts/install-opencv-m1.html",
    "href": "posts/install-opencv-m1.html",
    "title": "Building and Installing OpenCV 4.5.0 on an M1 Mac",
    "section": "",
    "text": "This post shows how to build and install OpenCV 4.5.0 on a MacBook Pro that comes with an M1 chip. Yes, you guessed it right - as of January 01, 2021, there‚Äôs no pre-compiled OpenCV binary compatible with this MacBook Pro variant. So, open up a terminal and get started!\nHere‚Äôs a brief summary of the configuration of my MacBook -"
  },
  {
    "objectID": "posts/install-opencv-m1.html#install-xcode-and-homebrew",
    "href": "posts/install-opencv-m1.html#install-xcode-and-homebrew",
    "title": "Building and Installing OpenCV 4.5.0 on an M1 Mac",
    "section": "Install Xcode and Homebrew",
    "text": "Install Xcode and Homebrew\nWe start by executing sudo xcodebuild -license from a terminal.\nWhen you execute the above command, you would need to accept the Xcode license. Then, in order to make use of Apple command line tools, we need to install it - sudo xcode-select --install.\nHomebrew manages packages on a Mac. In order to install it execute the following - /usr/bin/ruby -e \"%(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\".\nYou would want to add the command brew after the installation is complete. To do so, execute the following - nano ~/.zshrc\nThen insert export PATH=$PATH:/opt/homebrew/bin into it and press Ctrl + X from your keyboard. Then execute source ~/.zshrc from the terminal.\nNote that the exact path to Homebrew might be different for your system, so please double check that.\nNext up, we install a few system-level utilities required by OpenCV on a Mac."
  },
  {
    "objectID": "posts/install-opencv-m1.html#install-conda",
    "href": "posts/install-opencv-m1.html#install-conda",
    "title": "Building and Installing OpenCV 4.5.0 on an M1 Mac",
    "section": "Install conda",
    "text": "Install conda\nMy favorite Python virtual environment manager is virtualenv. Unfortunately, it does not play out that well with the new M1 chip. This is mostly because the pip-installable packages often break during their installations on the chip. This is why conda, specifically its miniforge distribution is the recommended package manager for a Mac shipped with M1. You can install it from here. This installs Python 3.8.\nAfter the installation is complete, please create a new Python virtual environment by executing conda create --name &lt;environment_name&gt;. Then activate it by running conda activate  &lt;environment_name&gt;.\nRunning conda install -y python==3.8.6 will install a few common Python packages for you. I highly recommend running this."
  },
  {
    "objectID": "posts/install-opencv-m1.html#install-numpy",
    "href": "posts/install-opencv-m1.html#install-numpy",
    "title": "Building and Installing OpenCV 4.5.0 on an M1 Mac",
    "section": "Install NumPy",
    "text": "Install NumPy\nNumPy is needed by OpenCV. So, we need to install it before we build and install OpenCV. Apple provides a numpy wheel that is compatible with the M1 chip. Follow the steps below to install it -\n% wget https://github.com/apple/tensorflow_macos/releases/download/v0.1alpha0/tensorflow_macos-0.1alpha0.tar.gz\n% tar xvf tensorflow_macos-0.1alpha0.tar.gz\n% cd tensorflow_macos/arm64\n% pip install --upgrade --no-dependencies --force numpy-1.18.5-cp38-cp38-macosx_11_0_arm64.whl \n% cd ~\n\n\n\n\n\n\nNote\n\n\n\nBe sure to activate your conda environment before doing the pip-install."
  },
  {
    "objectID": "posts/install-opencv-m1.html#compile-opencv",
    "href": "posts/install-opencv-m1.html#compile-opencv",
    "title": "Building and Installing OpenCV 4.5.0 on an M1 Mac",
    "section": "Compile OpenCV",
    "text": "Compile OpenCV\nFirst, let‚Äôs download the OpenCV and OpenCV extended module files and prepare them for compilation.\n% wget -O opencv.zip https://github.com/opencv/opencv/archive/4.5.0.zip\n% wget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/4.5.0.zip\n% unzip opencv.zip\n% unzip opencv_contrib.zip\n% cd opencv-4.5.0\n% mkdir build && cd build\nNow, we are all set to fire the cmake command that would build OpenCV for us. Let‚Äôs review it briefly -\n% cmake \\\n  -DCMAKE_SYSTEM_PROCESSOR=arm64 \\\n  -DCMAKE_OSX_ARCHITECTURES=arm64 \\\n  -DWITH_OPENJPEG=OFF \\\n  -DWITH_IPP=OFF \\\n  -D CMAKE_BUILD_TYPE=RELEASE \\\n  -D CMAKE_INSTALL_PREFIX=/usr/local \\\n  -D OPENCV_EXTRA_MODULES_PATH=/Users/sayakpaul/Downloads/opencv_contrib-4.5.0/modules \\\n  -D PYTHON3_EXECUTABLE=/Users/sayakpaul/miniforge3/envs/dev/bin/python3 \\\n  -D BUILD_opencv_python2=OFF \\\n  -D BUILD_opencv_python3=ON \\\n  -D INSTALL_PYTHON_EXAMPLES=ON \\\n  -D INSTALL_C_EXAMPLES=OFF \\\n  -D OPENCV_ENABLE_NONFREE=ON \\\n  -D BUILD_EXAMPLES=ON ..\nAs per this issue comment, DCMAKE_SYSTEM_PROCESSOR, DCMAKE_OSX_ARCHITECTURES, DWITH_OPENJPEG, and DWITH_IPP are needed to be set during the compilation step. Also, please pay attention to the following arguments - OPENCV_EXTRA_MODULES_PATH and PYTHON3_EXECUTABLE. For these two arguments, you would want to first determine the paths and then supply them accordingly.\nNow, before you run the above cmake command, activate the conda environment you created in an earlier step (conda activate &lt;environment_name&gt;) if you haven‚Äôt already. The compilation took ~3 minutes for me and it should produce outputs like so -\n\nNext, we launch the make command - make -j8. With all the eight cores (j8 stands for eight cores here) chugging along, this step took ~8 minutes for me. You can adjust the j option with respect to the hardware available. After it‚Äôs done you should get an output like so -\n\nThe final step here is to execute - sudo make install. It should take just a few seconds to complete execution. Upon successful completion, you should get an output like so -"
  },
  {
    "objectID": "posts/install-opencv-m1.html#sym-link-opencv-4-on-macos-to-virtual-environment-site-packages",
    "href": "posts/install-opencv-m1.html#sym-link-opencv-4-on-macos-to-virtual-environment-site-packages",
    "title": "Building and Installing OpenCV 4.5.0 on an M1 Mac",
    "section": "Sym-link OpenCV 4 on macOS to virtual environment site-packages",
    "text": "Sym-link OpenCV 4 on macOS to virtual environment site-packages\nTo do this, we first need to locate the .so file generated during the compilation step. We can do this with the mdfind command -\n% mdfind cv2.cpython\n/.../opencv-4.5.0/build/lib/python3/cv2.cpython-38-darwin.so\n/usr/local/lib/python3.8/site-packages/cv2/python-3.8/cv2.cpython-38-darwin.so\n...\nPlease note that I obfuscated some parts of the outputs for privacy reasons. In the above output, we can see the absolute locations for the .so files that were generated. Now, we need to execute the following to sym-link one of the .so files in our current Python virtual environment -\n% cd /.../miniforge3/envs/dev/lib/python3.8/site-packages\n% ln -s /usr/local/lib/python3.8/site-packages/cv2/python-3.8/cv2.cpython-38-darwin.so cv2.so\nPlease double-check the paths before executing the commands.\nAnd that‚Äôs it!\nYou can test the installation by executing the following -\n% conda activate &lt;environment_name&gt; (if you haven't already)\n% python\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; cv2.__version__\nIt should print '4.5.0'."
  },
  {
    "objectID": "posts/install-opencv-m1.html#references",
    "href": "posts/install-opencv-m1.html#references",
    "title": "Building and Installing OpenCV 4.5.0 on an M1 Mac",
    "section": "References",
    "text": "References\n\nInstall OpenCV 4 on macOS\nTensorFlow 2.4 on Apple Silicon M1 : installation under Conda environment"
  },
  {
    "objectID": "posts/streamlined-releases.html",
    "href": "posts/streamlined-releases.html",
    "title": "Streamlining PyPI Releases: A Case Study with üß® Diffusers",
    "section": "",
    "text": "Releasing a new version of an open-source library is an exhilarating experience. You ship new features, bug fixes, improved documentation, etc., to serve your users and also the mission of your library. Being one of the maintainers of the üß®¬†Diffusers library, I am no exception to this.\nOnce a release is finalized, it‚Äôs usually published on a software repository for the distribution programming language you‚Äôre using. Diffusers is a Python library, so PyPI is our publishing platform.\nIn this post, I share some of what I learned from trying to streamline the entire process of releasing a new version of the library and then publishing it. If you have similar responsibilities at your workplace or for your personal projects, this post might be helpful for you."
  },
  {
    "objectID": "posts/streamlined-releases.html#an-example-release-workflow-manual",
    "href": "posts/streamlined-releases.html#an-example-release-workflow-manual",
    "title": "Streamlining PyPI Releases: A Case Study with üß® Diffusers",
    "section": "An example release workflow (manual)",
    "text": "An example release workflow (manual)\nBefore we proceed to the other sections of the post, it will be helpful to have a schematic of what constitutes a release. Note that this workflow will vary from library to library, but some principles will still apply. I will take the workflow we follow for Diffusers as an example.\nThe steps are well laid out in setup.py and can be found here. Broadly, these are:\n\nPrepare the release branch and cut it out from the main.\nRun any test on the release branch and wait for them to pass. Fix any failures if needed.\nTag the release branch and push the tag.\nBuild the package source and wheel.\n\nUpload the package distribution to the Test PyPI server and run any tests.\nFinally, upload to the actual PyPI server.\n\nWe identified that steps 1-3 will always require a bit of human intervention and cannot be automated much (props if that‚Äôs not the case for you). But steps 3-6 can indeed be automated. These steps require more attention, too:\n\nWhen building the package distribution, one must delete the previous one before starting the build. Otherwise, it can have unintended consequences.\nManaging the credentials for the Test PyPI and PyPI servers.\nRunning any tests after publishing them on the Test PyPI server.\n\nThese steps would be better automated in your library‚Äôs Continuous Integration suite, greatly reducing the mental burden."
  },
  {
    "objectID": "posts/streamlined-releases.html#semi-automating-the-release-workflow",
    "href": "posts/streamlined-releases.html#semi-automating-the-release-workflow",
    "title": "Streamlining PyPI Releases: A Case Study with üß® Diffusers",
    "section": "Semi-automating the release workflow",
    "text": "Semi-automating the release workflow\nOnce we identified the above findings, we prepared a GitHub Actions workflow that gets triggered after a release is tagged and the tag is pushed. Additionally, we configured the workflow to be manually triggerable in case any intervention was needed.\nThis workflow takes the following steps:\n\nFind out the release branch so that it can be checked out for the sequential steps.\nSteps 3-6 as outlined in the above section.\n\nIt‚Äôs worth noting that the trigger for this kind of workflow should be figured out to suit what‚Äôs best for the given project. In the case of Diffusers, we realized that release steps that come after pushing the release tags can be largely automated. Hence, we went with that trigger.\nThe workflow file is available here. When successfully executed, it appears like so:\n\nYou can find the complete details about the action run here.\n\n\n\n\n\n\nPay attention to the dependencies\n\n\n\nThe initial workflow was missing a dependency that was needed to run the import tests after Test PyPI publishing. This was fixed in this PR. So, please double-check any dependency that might be needed to run the tests after your package has been published on the Test PyPI server.\n\n\nThe workflow doesn‚Äôt make use of any pre-built actions (such as pypa/gh-action-pypi-publish@v1.6.4) for publishing on PyPI. Instead, we decided to just follow what we‚Äôd do manually, i.e., use twine to manage the process. If you‚Äôre looking to use such an action, this can be a handy reference."
  },
  {
    "objectID": "posts/streamlined-releases.html#publishing-the-release-notes-and-communications",
    "href": "posts/streamlined-releases.html#publishing-the-release-notes-and-communications",
    "title": "Streamlining PyPI Releases: A Case Study with üß® Diffusers",
    "section": "Publishing the release notes and communications",
    "text": "Publishing the release notes and communications\nThe next step in the release process involves publishing the release notes on your repository and tagging it. Once a release is published, team members usually communicate about it internally within an organization and also more broadly with their communities through social media channels.\nOn the Diffusers team, we take release notes pretty seriously (example notes). This is why we intentionally keep the process of writing the notes and publishing them purely manual. Once a release is published on the repository, a workflow gets automatically triggered to communicate about it to an internal Slack channel. Successful execution of this workflow makes a bot automatically post the message below to a particular Slack channel:\n\nThis workflow can be found here.\nBoth the above steps were introduced in Diffusers through this PR. I recommend readers to go through it if they want to incorporate similar changes in their projects."
  },
  {
    "objectID": "posts/streamlined-releases.html#considerations",
    "href": "posts/streamlined-releases.html#considerations",
    "title": "Streamlining PyPI Releases: A Case Study with üß® Diffusers",
    "section": "Considerations",
    "text": "Considerations\nI played with the workflows rigorously on a dummy repository before introducing them in Diffusers. This is optional but highly recommended to confidently land similar changes in your actual projects.\nWe used incoming webhooks on Slack so that the bot could post messages. If you‚Äôre configuring something similar, this official tutorial can be quite useful."
  },
  {
    "objectID": "posts/attn-diffusion.html",
    "href": "posts/attn-diffusion.html",
    "title": "Flavors of attention in modern diffusion models",
    "section": "",
    "text": "Attention is a crucial component in generative neural architectures for continuous modalities like images and videos from natural language. More specifically, cross-attention helps to contextualize the relationship between the natural language prompt inputs and the media, being generated.\nWith modern diffusion models (or shall we say ‚Äúflow‚Äù) for condition-guided image and video generation, we saw the community going beyond cross-attention. For example, Stable Diffusion 3 (SD 3) [1] introduced ‚Äújoint-attention‚Äù in its MMDiT architecture. SANA [2], on the other hand, introduced a variant of ‚Äúlinear attention‚Äù, moving away from the standard attention mechanism.\nWhile the changes between these variants may appear architecturally simple, it can be helpful to understand the factors that distinguish them. In this post, we will investigate the popular forms of attention blocks used in modern diffusion models. We will tear them apart with simple PyTorch code and comment on some additional findings.\nReaders are expected to be familiar with diffusion-based image generation models and encoder-based transformer architectures.\nTable of contents:"
  },
  {
    "objectID": "posts/attn-diffusion.html#self-attention",
    "href": "posts/attn-diffusion.html#self-attention",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Self-attention",
    "text": "Self-attention\nFor the sake of completeness, let‚Äôs take a quick look at how self-attention is implemented. This will help us understand how it can be evolved to cross-attention and others.\ndef forward(self, x, attn_mask=None):\n    # x shape: (batch_size, seq_length, embed_dim)\n    bsz, seq_length, _ = x.size()\n    \n    # Compute queries, keys, and values using separate linear layers\n    q = self.to_q(x)  # shape: (batch_size, seq_length, embed_dim)\n    k = self.to_k(x)  # shape: (batch_size, seq_length, embed_dim)\n    v = self.to_v(x)  # shape: (batch_size, seq_length, embed_dim)\n    \n    # Reshape and transpose to get dimensions \n    # (batch_size, num_heads, seq_length, head_dim)\n    q = q.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    k = k.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    v = v.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    \n    # Compute scaled dot product attention using PyTorch's built-in function\n    attn_output = F.scaled_dot_product_attention(\n        q, k, v, attn_mask=attn_mask, dropout_p=self.dropout.p, is_causal=False\n    )  # shape: (batch_size, num_heads, seq_length, head_dim)\n    \n    # Combine the attention output from multiple heads\n    attn_output = attn_output.transpose(1, 2).reshape(bsz, seq_length, self.embed_dim)\n    \n    # Final linear projection\n    output = self.out_proj(attn_output)\n    return output\nWith self-attention, we model the interactions between the different parts of the same input.\nRegarding the implementation above, the initialization part of the underlying class was intentionally left out in the interest of brevity. We will follow this kind of snippets for the rest of this post."
  },
  {
    "objectID": "posts/attn-diffusion.html#cross-attention",
    "href": "posts/attn-diffusion.html#cross-attention",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Cross-attention",
    "text": "Cross-attention\nThe premise of cross-attention is we want to model how two different inputs interact with each other. For example, image patches and text tokens.\n+ def forward(self, x, context=None, attn_mask=None):\n    # x shape: (batch_size, seq_length, embed_dim)\n+    bsz, target_seq_len, _ = x.size()\n    \n+    if context is None:\n+        context = x\n+    source_seq_len = context.size(1)\n    \n+    # Compute queries from x; keys and values from context\n+    q = self.to_q(x)      # (batch_size, target_seq_length, embed_dim)\n+    k = self.to_k(context)  # (batch_size, source_seq_length, embed_dim)\n+    v = self.to_v(context)  # (batch_size, source_seq_length, embed_dim)\n    \n    # Reshape and transpose to get dimensions\n+    q = q.view(bsz, target_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n+    k = k.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n+    v = v.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n    \n    # Compute scaled dot product attention using PyTorch's built-in function\n    attn_output = F.scaled_dot_product_attention(\n        q, k, v, attn_mask=attn_mask, dropout_p=self.dropout.p, is_causal=False\n    )  # shape: (batch_size, num_heads, seq_length, head_dim)\n    \n    # Combine the attention output from multiple heads\n    attn_output = attn_output.transpose(1, 2).reshape(\n        bsz, target_seq_len, self.embed_dim\n    )\n    \n    # Final linear projection\n    output = self.out_proj(attn_output)\n    return output\nFor the context of this post, x would be the noisy latents we will denoise during inference and context would be the representations computed from input text prompts. In this case, the attention masks (attn_mask) are usually computed from the context. For example, for text prompts, the attention masks are constructed from the actual text tokens and the padding tokens.\nLet‚Äôs consider the sentence - ‚Äúa dog‚Äù. Without going into too many details, if we want to tokenize it with a maximum sequence length of 10, the attention masks would look like so:\n[1, 1, 1, 1, 0, 0, 0, 0, 0, 0]\nThe exact text tokens would change based on the tokenizer being used but we get the idea of how attention masks might look like.\nWith the presence of attention masks, attention computation accelerates while also reducing memory footprint.\nThis implementation often meets with other elements that help stabilize training, improve the end performance, extrapolate to larger resolutions, etc. Some of these popular elements include:\nQK normalization\nIntroduced in ViT-22B [3], QK normalization is a commonly used technique to help stabilize the training of transformers at scale. In code, this is simple to implement:\n...\nq = self.to_q(x)\nk = self.to_k(k)\n...\n\n+ q = self.q_norm_layer(q)\n+ k = self.k_norm_layer(k)\n...\nSome choices of norms include LayerNorm, RMSNorm, and L2Norm, with the first two being the most common.\nGrouped-query attention (GQA)\nIn the standard attention, every query in the sequence independently computes its attention weights with every key. But there may be redundancy [4] in this setup. We can maintain a reduced space for the keys, and the values repeat them across groups of queries. In practice, this looks like so:\n...\nq = self.to_q(x) # (batch_size, seq_length, embed_dim)\n+ k = self.to_k(context) # (batch_size, context_seq_length, embed_dim // reduced_kv_heads)\n+ v = self.to_v(context) # (batch_size, context_seq_length, embed_dim // reduced_kv_heads)\n\n# Note there's no transpose yet (.transpose(1, 2)).\nq = q.view(batch_size, target_seq_length, self.num_heads, self.head_dim)\n+ k = k.view(batch_size, source_seq_length, self.kv_heads, self.head_dim)\n+ v = v.view(batch_size, source_seq_length, self.kv_heads, self.head_dim)\n\n+ n_rep = self.num_heads // self.kv_heads\n+ if n_rep &gt;= 1:\n+       # Perform repeats.\n+    k = k.unsqueeze(3).repeat(1, 1, 1, n_rep, 1).flatten(2, 3)\n+    v = v.unsqueeze(3).repeat(1, 1, 1, n_rep, 1).flatten(2, 3)\n\n+ # Complete the transpose to get (batch_size, num_heads, seq_length, head_dim).\n+ q = q.transpose(1, 2)\n+ k = k.transpose(1, 2)\n+ v = v.transpose(1, 2)\n\n# Apply `scaled_dot_product_attention()`\n...\nThis helps reduce memory overhead without hurting performance too much. This is crucial when generating high-resolution images and videos.\nRotary position embeddings (RoPE)\nRotary position embeddings have become de facto as they help extrapolate to longer sequences. Image (and video) generation is no exception! The explanation of RoPE is out of this post‚Äôs scope. Interested readers should check out this post, instead.\nBelow, we provide where RoPE is usually incorporated when computing attention:\n...\n\nq = self.to_q(x) # (batch_size, seq_length, embed_dim)\nk = self.to_k(context) # (batch_size, context_seq_length, embed_dim)\nv = self.to_v(context) # (batch_size, context_seq_length, embed_dim)\n\n# Note there's no transpose yet (.transpose(1, 2)).\nq = q.view(batch_size, target_seq_length, self.num_heads, self.head_dim)\nk = k.view(batch_size, source_seq_length, self.num_heads, self.head_dim)\nv = v.view(batch_size, source_seq_length, self.num_heads, self.head_dim) \n\n# The `*_rotary_emb()` below are computed based on the inputs.\n+ query = apply_rotary_emb(query, query_rotary_emb, use_real=False)\n+ key = apply_rotary_emb(key, key_rotary_emb, use_real=False)\n\n...\nPopular models that use cross-attention include Stable Diffusion XL [5], PixArt-{Alpha. Sigma} [6, 7], Lumina-Next [8], LTX-Video [9], etc. Lumina-Next incorporates all the other elements as well."
  },
  {
    "objectID": "posts/attn-diffusion.html#joint-attention",
    "href": "posts/attn-diffusion.html#joint-attention",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Joint-attention",
    "text": "Joint-attention\nThrough cross-attention, we also inherit any bias that might be present in the prompt embeddings computed with text encoders. For example, if a text encoder exhibits a unidirectional bias (through causal attention), that can creep unexpectedly into the diffusion model representations. Joint-attention alleviates this by allowing the representations coming from two different modalities to co-evolve with training.\nThe diagram below depicts the MMDiT architecture, which also introduces joint-attention.\n\n\n\nMMDiT architecture. Figure taken from SD 3 paper [1].\n\nIf the diagram appears to be overwhelming, don‚Äôt worry, the implementation of it is simpler than one might think. In a nutshell, in joint-attention, the QKV projection is performed separately (with separate sets of params) on each of the two modalities shown above (c being the representation computed from the text prompts and x being noisy latents to be denoised). Before computing the attention, these projections are concatenated. Quoting from the SD3 paper [1]:\n\nSince text and image embeddings are conceptually quite different, we use two separate sets of weights for the two modalities. [‚Ä¶], this is equivalent to having two independent transformers for each modality, but joining the sequences of the two modalities for the attention operation, such that both representations can work in their own space yet take the other one into account.\n\nInterested readers can check out this thread for more insights from the community.\nLet‚Äôs now turn our attention to how it is implemented in practice.\ndef forward(self, x, context=None, attn_mask=None):\n    if context is not None:\n        source_seq_len = context.size(1)\n    \n    bsz, target_seq_len, _ = x.size()\n    \n    # Compute projections on the different modalities separately\n    q = self.to_q(x)      \n    k = self.to_k(x)  \n    v = self.to_v(x)  \n\n    # Reshape and transpose for multi-head attention\n    q = q.view(bsz, target_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n    k = k.view(bsz, target_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n    v = v.view(bsz, target_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n\n    # Compute projections on the condition separately\n    if context is not None:\n        context_q = self.to_add_q(context) \n        context_k = self.to_add_k(context)\n        context_v = self.to_add_v(context)\n        \n        context_q = context_q.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n        context_k = context_k.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n        context_v = context_v.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n\n        # Concatenate across the sequence length dimension\n        q = torch.cat([context_q, q], dim=2)\n        k = torch.cat([context_k, k], dim=2)\n        v = torch.cat([context_v, v], dim=2)\n    \n    # Compute scaled dot product attention\n    attn_output = F.scaled_dot_product_attention(\n        q, k, v, attn_mask=attn_mask, dropout_p=self.dropout.p, is_causal=False\n    )  \n    \n    # Combine attention heads\n    attn_output = attn_output.transpose(1, 2).reshape(\n        bsz, target_seq_len, self.embed_dim\n    )\n\n    # Seperate context from latents and final linear projection\n    if context is not None:\n        context, x = (\n            attn_output[:, : source_seq_len],\n            attn_output[:, source_seq_len :],\n        )\n        context = self.add_out_proj(context)\n        x = self.out_proj(x)\n\n        return x, context\n    \n    else:\n        return self.out_proj(attn_output)\nWith joint-attention, it becomes unclear how to incorporate attention masks while computing attention and how much of a performance penalty it incurs due to that.\nPart joint-attention, part self-attention\nSubsequent works like AuraFlow [10] and Flux [11] introduced a small change in the original MMDiT architecture. They use joint attention for the first few layers within the diffusion transformer. They then concatenate the two different outputs and operate on the concatenated output. As per the AuraFlow authors, it helps with better FLOPs optimization. In pseudo-code, it looks like so:\n# Regular MMDiT blocks.\nfor block in self.double_blocks:\n    context, x = block(\n        x=x,\n        context=context, \n        ...\n    )\n\n# Concatenate.\ncontext_x = torch.cat([context, x], dim=1)  \n\n# Continue with the rest.\nfor block in self.single_blocks:\n    x = block(x=context_x, ...) \nThe joint-attention implementation provided above is already equipped to handle situations when context may not be provided while computing attention (the context is not None code path).\nAttention gymnastics\nFlux, additionally, improves the hardware efficiency by using parallel layers [3]. To better understand how parallel layers can be helpful in improving efficiency, let‚Äôs look at the first set of equations that govern an encoder-style transformer block:\n\\[\n\\begin{aligned}\n& y^{\\prime}=\\operatorname{LayerNorm}(x) \\\\\n& y=x+\\operatorname{MLP}\\left(y^{\\prime}\\right)+\\operatorname{Attention}\\left(y^{\\prime}\\right)\n\\end{aligned}\n\\]\nWe can combine the linear projection layers of attention (QKV) and the MLP. From the ViT-22B paper:\n\nIn particular, the matrix multiplication for query/key/value-projections and the first linear layer of the MLP are fused into a single operation, and the same is done for the attention out-projection and second linear layer of the MLP.\n\nTo understand how it is implemented in practice, we first need to understand QKV fusion. It lets us perform the three different projections involved in attention in one go. Instead of having three different projection layers, we only keep one:\n...\n# This becomes\nself.to_q = nn.Linear(embed_dim, embed_dim)\nself.to_k = nn.Linear(embed_dim, embed_dim)\nself.to_v = nn.Linear(embed_dim, embed_dim)\n\n# this ‚¨áÔ∏è\nself.to_qkv = nn.Linear(embed_dim, embed_dim * 3)\nThen, during the forward pass, we do:\n...\nqkv = self.to_qkv(x)\nsplit_size = qkv.shape[-1] // 3\nq, k, v = torch.split(qkv, split_size, dim=-1)\n\n# Rest of the process is the same\n...\nNow, to incorporate the MLP into the mix, we need some changes in the initialization:\n...\n# MLP ratio is typically 4.\n# The first part of fusion. QKV + first layer of an MLP from a transformer block.\nself.qkv_mlp_first = nn.Linear(embed_dim, embed_dim * (3 + mlp_ratio))\n\n# Second part of fusion. Attention out projection + second MLP layer.\nself.attn_proj_mlp_second = nn.Linear(\n    embed_dim + embed_dim * mlp_ratio, embed_dim\n)\nThe forward pass would be:\nqkv, mlp = torch.split(\n    self.qkv_mlp_first(x_mod), \n    [3 * self.embed_dim, int(self.embed_dim * self.mlp_ratio)], \n    dim=-1\n)\nq, k, v = torch.split(qkv, qkv.shape[-1] // 3, dim=-1)\n\n# Compute attention\n...\n\n# MLP computation\nconcat_attn_mlp_in = torch.cat((attn_output, self.mlp_act(mlp)), 2)\noutput = self.attn_proj_mlp_second(concat_attn_mlp_in)\nThe ViT-22B paper [3] also provides a great visualization for this:\n\n\n\nTransformer block with parallel layers. Figure taken from the ViT-22B paper [3].\n\nIt is also a good idea to mention that some of the other elements we discussed earlier ‚Äî QK normalization, GQA, and RoPE ‚Äî can also be combined with joint attention. One of the most popular models, Flux, uses QK normalization and RoPE. Lumina2 [12] combines all three and uses joint-attention with a twist:\n\nIt first uses very few layers of self-attention transformer blocks separately on the noisy latents and the conditional representations.\nIt then combines the two representations and runs it through a number of self-attention transformer blocks.\n\nInterested readers can check out the implementation details here. The figure below provides a side-by-side comparison of the differences in attention used in SD3 and Lumina2:\n\n\n\nComparison between the attention schemes used in SD3 and Lumina2, respectively. Figures were intentionally simplified to convey the main idea.\n\n\nLinear attention\nAs the world already knows, attention has a quadratic time complexity. This can pose prohibitive challenges when operating with very long sequences despite improved techniques like Flash Attention.\nSANA [2] replaced all vanilla attention with linear attention. More specifically, in each of its transformer blocks, SANA has two kinds of attention:\n\nlinear self-attention for the noisy latents,\nregular cross-attention for the noisy latents (x) and the condition representations (context).\n\nTo facilitate local interactions between the tokens, it used ‚ÄúMix-FFN‚Äù blocks [13], [14].\n\n\n\nLinear attention block and the Mix-FFN block. Figure taken from the SANA paper [2].\n\nImplementation of this linear-attention variant is by far the simplest. We show the main changes introduced when compared to the classic self-attention:\ndef forward(self, x):\n    # x shape: (batch_size, seq_length, embed_dim)\n    bsz, seq_length, _ = x.size()\n    \n    # Compute queries, keys, and values using separate linear layers\n    q = self.to_q(x)  # shape: (batch_size, seq_length, embed_dim)\n    k = self.to_k(x)  # shape: (batch_size, seq_length, embed_dim)\n    v = self.to_v(x)  # shape: (batch_size, seq_length, embed_dim)\n    \n    # Reshape and transpose to get dimensions \n    # (batch_size, num_heads, seq_length, head_dim)\n    q = q.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    k = k.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    v = v.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n\n+   # Reshape to (batch_size, seq_length, num_heads, head_dim)\n+   q = q.transpose(2, 3)\n+   v = v.transpose(2, 3)\n    \n+    # Introduce non-linearity\n+    q = F.relu(q)\n+    k = F.relu(k)\n\n+    # Combine scores\n+    scores = torch.matmul(v, k)\n+    x = torch.matmul(scores, q)\n    \n+    # Scale\n+    x = x[:, :, :-1] / (x[:, :, -1:] + 1e-15)\n    \n    # Combine the output from multiple heads\n    x = x.transpose(1, 2).reshape(bsz, seq_length, self.embed_dim)\n    \n    # Final linear projection\n    output = self.out_proj(x)\n    return output\nIt‚Äôs also worth pointing out that SANA uses no positional encodings (so-called NoPE). The SANA authors conjectured that the use of Mix-FFN blocks helped them get away with NoPE without incurring any loss in performance.\n\nThoughts\nThroughout the course of this post, we saw many architectural configurations of the attention mechanism. Some questions that may still arise:\n\nIs there any benefit to using cross-attention for image-video generation at all?\nHow can we compensate for the compute intensity of joint-attention?\nIs the Lumina2 way of doing joint-attention the way to go?\nIs it necessary to do masking in joint-attention? If so, what are the benefits?\n\nIn defense of the widely adopted and optimized vanilla attention, could we interleave quadratic attention and window attention (as done in Gemma2 [15])?\nAll of these questions (and possibly more) warrant a careful ablation study.\nAcknowledgements: Thanks to Aritra Roy Gosthipaty for useful feedback."
  },
  {
    "objectID": "posts/attn-diffusion.html#linear-attention",
    "href": "posts/attn-diffusion.html#linear-attention",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Linear attention",
    "text": "Linear attention\nAs the world already knows, attention has a quadratic time complexity. This can pose prohibitive challenges when operating with very long sequences despite improved techniques like Flash Attention.\nSANA [2] replaced all vanilla attention with linear attention. More specifically, in each of its transformer blocks, SANA has two kinds of attention:\n\nlinear self-attention for the noisy latents,\nregular cross-attention for the noisy latents (x) and the condition representations (context).\n\nTo facilitate local interactions between the tokens, it used ‚ÄúMix-FFN‚Äù blocks [13], [14].\n\n\n\nLinear attention block and the Mix-FFN block. Figure taken from the SANA paper [2].\n\nImplementation of this linear-attention variant is by far the simplest. We show the main changes introduced when compared to the classic self-attention:\ndef forward(self, x):\n    # x shape: (batch_size, seq_length, embed_dim)\n    bsz, seq_length, _ = x.size()\n    \n    # Compute queries, keys, and values using separate linear layers\n    q = self.to_q(x)  # shape: (batch_size, seq_length, embed_dim)\n    k = self.to_k(x)  # shape: (batch_size, seq_length, embed_dim)\n    v = self.to_v(x)  # shape: (batch_size, seq_length, embed_dim)\n    \n    # Reshape and transpose to get dimensions \n    # (batch_size, num_heads, seq_length, head_dim)\n    q = q.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    k = k.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    v = v.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n\n+   # Reshape to (batch_size, seq_length, num_heads, head_dim)\n+   q = q.transpose(2, 3)\n+   v = v.transpose(2, 3)\n    \n+    # Introduce non-linearity\n+    q = F.relu(q)\n+    k = F.relu(k)\n\n+    # Combine scores\n+    scores = torch.matmul(v, k)\n+    x = torch.matmul(scores, q)\n    \n+    # Scale\n+    x = x[:, :, :-1] / (x[:, :, -1:] + 1e-15)\n    \n    # Combine the output from multiple heads\n    x = x.transpose(1, 2).reshape(bsz, seq_length, self.embed_dim)\n    \n    # Final linear projection\n    output = self.out_proj(x)\n    return output\nIt‚Äôs also worth pointing out that SANA uses no positional encodings (so-called NoPE). The SANA authors conjectured that the use of Mix-FFN blocks helped them get away with NoPE without incurring any loss in performance.\n\nThoughts\nThroughout the course of this post, we saw many architectural configurations of the attention mechanism. Some questions that may still arise:\n\nIs there any benefit to using cross-attention for image-video generation at all?\nHow can we compensate for the compute intensity of joint-attention?\nIs the Lumina2 way of doing joint-attention the way to go?\nIs it necessary to do masking in joint-attention? If so, what are the benefits?\n\nIn defense of the widely adopted and optimized vanilla attention, could we interleave quadratic attention and window attention (as done in Gemma2 [15])?\nAll of these questions (and possibly more) warrant a careful ablation study.\nAcknowledgements: Thanks to Aritra Roy Gosthipaty for useful feedback."
  },
  {
    "objectID": "posts/attn-diffusion.html#thoughts",
    "href": "posts/attn-diffusion.html#thoughts",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Thoughts",
    "text": "Thoughts\nThroughout the course of this post, we saw many architectural configurations of the attention mechanism. Some questions that may still arise:\n\nIs there any benefit to using cross-attention for image-video generation at all?\nHow can we compensate for the compute intensity of joint-attention?\nIs the Lumina2 way of doing joint-attention the way to go?\nIs it necessary to do masking in joint-attention? If so, what are the benefits?\n\nIn defense of the widely adopted and optimized vanilla attention, could we interleave quadratic attention and window attention (as done in Gemma2 [15])?\nAll of these questions (and possibly more) warrant a careful ablation study.\nAcknowledgements: Thanks to Aritra Roy Gosthipaty for useful feedback."
  },
  {
    "objectID": "posts/attn-diffusion-2.html",
    "href": "posts/attn-diffusion-2.html",
    "title": "Flavors of attention in modern diffusion models",
    "section": "",
    "text": "Attention is a crucial component in generative neural architectures for continuous modalities like images and videos from natural language. More specifically, cross-attention helps to contextualize the relationship between the natural language prompt inputs and the media, being generated.\nWith modern diffusion models (or shall we say ‚Äúflow‚Äù) for condition-guided image and video generation, we saw the community going beyond cross-attention. For example, Stable Diffusion 3 (SD 3) [1] introduced ‚Äújoint-attention‚Äù in its MMDiT architecture. SANA [2], on the other hand, introduced a variant of ‚Äúlinear attention‚Äù, moving away from the standard attention mechanism.\nWhile the changes between these variants may appear architecturally simple, it can be helpful to understand the factors that distinguish them. In this post, we will investigate the popular forms of attention blocks used in modern diffusion models. We will tear them apart with simple PyTorch code and comment on some additional findings.\nReaders are expected to be familiar with diffusion-based image generation models and encoder-based transformer architectures.\nTable of contents:"
  },
  {
    "objectID": "posts/attn-diffusion-2.html#self-attention",
    "href": "posts/attn-diffusion-2.html#self-attention",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Self-attention",
    "text": "Self-attention\nFor the sake of completeness, let‚Äôs take a quick look at how self-attention is implemented. This will help us understand how it can be evolved to cross-attention and others.\ndef forward(self, x, attn_mask=None):\n    # x shape: (batch_size, seq_length, embed_dim)\n    bsz, seq_length, _ = x.size()\n    \n    # Compute queries, keys, and values using separate linear layers\n    q = self.to_q(x)  # shape: (batch_size, seq_length, embed_dim)\n    k = self.to_k(x)  # shape: (batch_size, seq_length, embed_dim)\n    v = self.to_v(x)  # shape: (batch_size, seq_length, embed_dim)\n    \n    # Reshape and transpose to get dimensions\n    # (batch_size, num_heads, seq_length, head_dim)\n    q = q.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    k = k.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    v = v.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    \n    # Compute scaled dot product attention using PyTorch's built-in function\n    attn_output = F.scaled_dot_product_attention(\n        q, k, v, attn_mask=attn_mask, dropout_p=self.dropout.p, is_causal=False\n    )  # shape: (batch_size, num_heads, seq_length, head_dim)\n    \n    # Combine the attention output from multiple heads\n    attn_output = attn_output.transpose(1, 2).reshape(bsz, seq_length, self.embed_dim)\n    \n    # Final linear projection\n    output = self.out_proj(attn_output)\n    return output\nWith self-attention, we model the interactions between the different parts of the same input.\nRegarding the implementation above, the initialization part of the underlying class was intentionally left out in the interest of brevity. We will follow this kind of snippets for the rest of this post."
  },
  {
    "objectID": "posts/attn-diffusion-2.html#cross-attention",
    "href": "posts/attn-diffusion-2.html#cross-attention",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Cross-attention",
    "text": "Cross-attention\nThe premise of cross-attention is we want to model how two different inputs interact with each other. For example, image patches and text tokens.\n+ def forward(self, x, context=None, attn_mask=None):\n    # x shape: (batch_size, seq_length, embed_dim)\n+    bsz, target_seq_len, _ = x.size()\n    \n+    if context is None:\n+        context = x\n+    source_seq_len = context.size(1)\n    \n+    # Compute queries from x; keys and values from context\n+    q = self.to_q(x)      # (batch_size, target_seq_length, embed_dim)\n+    k = self.to_k(context)  # (batch_size, source_seq_length, embed_dim)\n+    v = self.to_v(context)  # (batch_size, source_seq_length, embed_dim)\n    \n    # Reshape and transpose to get dimensions\n+    q = q.view(bsz, target_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n+    k = k.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n+    v = v.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n    \n    # Compute scaled dot product attention using PyTorch's built-in function\n    attn_output = F.scaled_dot_product_attention(\n        q, k, v, attn_mask=attn_mask, dropout_p=self.dropout.p, is_causal=False\n    )  # shape: (batch_size, num_heads, seq_length, head_dim)\n    \n    # Combine the attention output from multiple heads\n    attn_output = attn_output.transpose(1, 2).reshape(\n        bsz, target_seq_len, self.embed_dim\n    )\n    \n    # Final linear projection\n    output = self.out_proj(attn_output)\n    return output\nFor the context of this post, x would be the noisy latents we will denoise during inference and context would be the representations computed from input text prompts. In this case, the attention masks (attn_mask) are usually computed from the context. For example, for text prompts, the attention masks are constructed from the actual text tokens and the padding tokens.\nLet‚Äôs consider the sentence - ‚Äúa dog‚Äù. Without going into too many details, if we want to tokenize it with a maximum sequence length of 10, the attention masks would look like so:\n[1, 1, 1, 1, 0, 0, 0, 0, 0, 0]\nThe exact text tokens would change based on the tokenizer being used but we get the idea of how attention masks might look like.\nWith the presence of attention masks, attention computation accelerates while also reducing memory footprint.\nThis implementation often meets with other elements that help stabilize training, improve the end performance, extrapolate to larger resolutions, etc. Some of these popular elements include:\nQK normalization\nIntroduced in ViT-22B [3], QK normalization is a commonly used technique to help stabilize the training of transformers at scale. In code, this is simple to implement:\n...\nq = self.to_q(x)\nk = self.to_k(k)\n...\n\n+ q = self.q_norm_layer(q)\n+ k = self.k_norm_layer(k)\n...\nSome choices of norms include LayerNorm, RMSNorm, and L2Norm, with the first two being the most common.\nGrouped-query attention (GQA)\nIn the standard attention, every query in the sequence independently computes its attention weights with every key. But there may be redundancy [4] in this setup. We can maintain a reduced space for the keys, and the values repeat them across groups of queries. In practice, this looks like so:\n...\nq = self.to_q(x) # (batch_size, seq_length, embed_dim)\n+ k = self.to_k(context) # (batch_size, context_seq_length, embed_dim // reduced_kv_heads)\n+ v = self.to_v(context) # (batch_size, context_seq_length, embed_dim // reduced_kv_heads)\n\n# Note there's no transpose yet (.transpose(1, 2)).\nq = q.view(batch_size, target_seq_length, self.num_heads, self.head_dim)\n+ k = k.view(batch_size, source_seq_length, self.kv_heads, self.head_dim)\n+ v = v.view(batch_size, source_seq_length, self.kv_heads, self.head_dim)\n\n+ n_rep = self.num_heads // self.kv_heads\n+ if n_rep &gt;= 1:\n+       # Perform repeats.\n+    k = k.unsqueeze(3).repeat(1, 1, 1, n_rep, 1).flatten(2, 3)\n+    v = v.unsqueeze(3).repeat(1, 1, 1, n_rep, 1).flatten(2, 3)\n\n+ # Complete the transpose to get (batch_size, num_heads, seq_length, head_dim).\n+ q = q.transpose(1, 2)\n+ k = k.transpose(1, 2)\n+ v = v.transpose(1, 2)\n\n# Apply `scaled_dot_product_attention()`\n...\nThis helps reduce memory overhead without hurting performance too much. This is crucial when generating high-resolution images and videos.\nRotary position embeddings (RoPE)\nRotary position embeddings have become de facto as they help extrapolate to longer sequences. Image (and video) generation is no exception! The explanation of RoPE is out of this post‚Äôs scope. Interested readers should check out this post, instead.\nBelow, we provide where RoPE is usually incorporated when computing attention:\n...\n\nq = self.to_q(x) # (batch_size, seq_length, embed_dim)\nk = self.to_k(context) # (batch_size, context_seq_length, embed_dim)\nv = self.to_v(context) # (batch_size, context_seq_length, embed_dim)\n\n# Note there's no transpose yet (.transpose(1, 2)).\nq = q.view(batch_size, target_seq_length, self.num_heads, self.head_dim)\nk = k.view(batch_size, source_seq_length, self.num_heads, self.head_dim)\nv = v.view(batch_size, source_seq_length, self.num_heads, self.head_dim)\n\n# The `*_rotary_emb()` below are computed based on the inputs.\n+ query = apply_rotary_emb(query, query_rotary_emb, use_real=False)\n+ key = apply_rotary_emb(key, key_rotary_emb, use_real=False)\n\n...\nPopular models that use cross-attention include Stable Diffusion XL [5], PixArt-{Alpha. Sigma} [6, 7], Lumina-Next [8], LTX-Video [9], etc. Lumina-Next incorporates all the other elements as well."
  },
  {
    "objectID": "posts/attn-diffusion-2.html#joint-attention",
    "href": "posts/attn-diffusion-2.html#joint-attention",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Joint-attention",
    "text": "Joint-attention\nThrough cross-attention, we also inherit any bias that might be present in the prompt embeddings computed with text encoders. For example, if a text encoder exhibits a unidirectional bias (through causal attention), that can creep unexpectedly into the diffusion model representations. Joint-attention alleviates this by allowing the representations coming from two different modalities to co-evolve with training.\nThe diagram below depicts the MMDiT architecture, which also introduces joint-attention.\n\n\n\nMMDiT architecture. Figure taken from SD 3 paper [1].\n\nIf the diagram appears to be overwhelming, don‚Äôt worry, the implementation of it is simpler than one might think. In a nutshell, in joint-attention, the QKV projection is performed separately (with separate sets of params) on each of the two modalities shown above (c being the representation computed from the text prompts and x being noisy latents to be denoised). Before computing the attention, these projections are concatenated. Quoting from the SD3 paper [1]:\n\nSince text and image embeddings are conceptually quite different, we use two separate sets of weights for the two modalities. [‚Ä¶], this is equivalent to having two independent transformers for each modality, but joining the sequences of the two modalities for the attention operation, such that both representations can work in their own space yet take the other one into account.\n\nInterested readers can check out this thread for more insights from the community.\nLet‚Äôs now turn our attention to how it is implemented in practice.\ndef forward(self, x, context=None, attn_mask=None):\n    if context is not None:\n        source_seq_len = context.size(1)\n    \n    bsz, target_seq_len, _ = x.size()\n    \n    # Compute projections on the different modalities separately\n    q = self.to_q(x)      \n    k = self.to_k(x)  \n    v = self.to_v(x)  \n\n    # Reshape and transpose for multi-head attention\n    q = q.view(bsz, target_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n    k = k.view(bsz, target_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n    v = v.view(bsz, target_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n\n    # Compute projections on the condition separately\n    if context is not None:\n        context_q = self.to_add_q(context)\n        context_k = self.to_add_k(context)\n        context_v = self.to_add_v(context)\n        \n        context_q = context_q.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n        context_k = context_k.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n        context_v = context_v.view(bsz, source_seq_len, self.num_heads, self.head_dim).transpose(1, 2)\n\n        # Concatenate across the sequence length dimension\n        q = torch.cat([context_q, q], dim=2)\n        k = torch.cat([context_k, k], dim=2)\n        v = torch.cat([context_v, v], dim=2)\n    \n    # Compute scaled dot product attention\n    attn_output = F.scaled_dot_product_attention(\n        q, k, v, attn_mask=attn_mask, dropout_p=self.dropout.p, is_causal=False\n    )  \n    \n    # Combine attention heads\n    attn_output = attn_output.transpose(1, 2).reshape(\n        bsz, target_seq_len, self.embed_dim\n    )\n\n    # Seperate context from latents and final linear projection\n    if context is not None:\n        context, x = (\n            attn_output[:, : source_seq_len],\n            attn_output[:, source_seq_len :],\n        )\n        context = self.add_out_proj(context)\n        x = self.out_proj(x)\n\n        return x, context\n    \n    else:\n        return self.out_proj(attn_output)\nWith joint-attention, it becomes unclear how to incorporate attention masks while computing attention and how much of a performance penalty it incurs due to that.\nPart joint-attention, part self-attention\nSubsequent works like AuraFlow [10] and Flux [11] introduced a small change in the original MMDiT architecture. They use joint attention for the first few layers within the diffusion transformer. They then concatenate the two different outputs and operate on the concatenated output. As per the AuraFlow authors, it helps with better FLOPs optimization. In pseudo-code, it looks like so:\n# Regular MMDiT blocks.\nfor block in self.double_blocks:\n    context, x = block(\n        x=x,\n        context=context,\n        ...\n    )\n\n# Concatenate.\ncontext_x = torch.cat([context, x], dim=1)  \n\n# Continue with the rest.\nfor block in self.single_blocks:\n    x = block(x=context_x, ...)\nThe joint-attention implementation provided above is already equipped to handle situations when context may not be provided while computing attention (the context is not None code path).\nAttention gymnastics\nFlux, additionally, improves the hardware efficiency by using parallel layers [3]. To better understand how parallel layers can be helpful in improving efficiency, let‚Äôs look at the first set of equations that govern an encoder-style transformer block:\n\\[\n\\begin{aligned}\n& y^{\\prime}=\\operatorname{LayerNorm}(x) \\\\\n& y=x+\\operatorname{MLP}\\left(y^{\\prime}\\right)+\\operatorname{Attention}\\left(y^{\\prime}\\right)\n\\end{aligned}\n\\]\nWe can combine the linear projection layers of attention (QKV) and the MLP. From the ViT-22B paper:\n\nIn particular, the matrix multiplication for query/key/value-projections and the first linear layer of the MLP are fused into a single operation, and the same is done for the attention out-projection and second linear layer of the MLP.\n\nTo understand how it is implemented in practice, we first need to understand QKV fusion. It lets us perform the three different projections involved in attention in one go. Instead of having three different projection layers, we only keep one:\n...\n# This becomes\nself.to_q = nn.Linear(embed_dim, embed_dim)\nself.to_k = nn.Linear(embed_dim, embed_dim)\nself.to_v = nn.Linear(embed_dim, embed_dim)\n\n# this ‚¨áÔ∏è\nself.to_qkv = nn.Linear(embed_dim, embed_dim * 3)\nThen, during the forward pass, we do:\n...\nqkv = self.to_qkv(x)\nsplit_size = qkv.shape[-1] // 3\nq, k, v = torch.split(qkv, split_size, dim=-1)\n\n# Rest of the process is the same\n...\nNow, to incorporate the MLP into the mix, we need some changes in the initialization:\n...\n# MLP ratio is typically 4.\n# The first part of fusion. QKV + first layer of an MLP from a transformer block.\nself.qkv_mlp_first = nn.Linear(embed_dim, embed_dim * (3 + mlp_ratio))\n\n# Second part of fusion. Attention out projection + second MLP layer.\nself.attn_proj_mlp_second = nn.Linear(\n    embed_dim + embed_dim * mlp_ratio, embed_dim\n)\nThe forward pass would be:\nqkv, mlp = torch.split(\n    self.qkv_mlp_first(x_mod),\n    [3 * self.embed_dim, int(self.embed_dim * self.mlp_ratio)],\n    dim=-1\n)\nq, k, v = torch.split(qkv, qkv.shape[-1] // 3, dim=-1)\n\n# Compute attention\n...\n\n# MLP computation\nconcat_attn_mlp_in = torch.cat((attn_output, self.mlp_act(mlp)), 2)\noutput = self.attn_proj_mlp_second(concat_attn_mlp_in)\nThe ViT-22B paper [3] also provides a great visualization for this:\n\n\n\nTransformer block with parallel layers. Figure taken from the ViT-22B paper [3].\n\nIt is also a good idea to mention that some of the other elements we discussed earlier ‚Äî QK normalization, GQA, and RoPE ‚Äî can also be combined with joint attention. One of the most popular models, Flux, uses QK normalization and RoPE. Lumina2 [12] combines all three and uses joint-attention with a twist:\n\nIt first uses very few layers of self-attention transformer blocks separately on the noisy latents and the conditional representations.\nIt then combines the two representations and runs it through a number of self-attention transformer blocks.\n\nInterested readers can check out the implementation details here. The figure below provides a side-by-side comparison of the differences in attention used in SD3 and Lumina2:\n\n\n\nComparison between the attention schemes used in SD3 and Lumina2, respectively. Figures were intentionally simplified to convey the main idea.\n\n\nLinear attention\nAs the world already knows, attention has a quadratic time complexity. This can pose prohibitive challenges when operating with very long sequences despite improved techniques like Flash Attention.\nSANA [2] replaced all vanilla attention with linear attention. More specifically, in each of its transformer blocks, SANA has two kinds of attention:\n\nlinear self-attention for the noisy latents,\nregular cross-attention for the noisy latents (x) and the condition representations (context).\n\nTo facilitate local interactions between the tokens, it used ‚ÄúMix-FFN‚Äù blocks [13], [14].\n\n\n\nLinear attention block and the Mix-FFN block. Figure taken from the SANA paper [2].\n\nImplementation of this linear-attention variant is by far the simplest. We show the main changes introduced when compared to the classic self-attention:\ndef forward(self, x):\n    # x shape: (batch_size, seq_length, embed_dim)\n    bsz, seq_length, _ = x.size()\n    \n    # Compute queries, keys, and values using separate linear layers\n    q = self.to_q(x)  # shape: (batch_size, seq_length, embed_dim)\n    k = self.to_k(x)  # shape: (batch_size, seq_length, embed_dim)\n    v = self.to_v(x)  # shape: (batch_size, seq_length, embed_dim)\n    \n    # Reshape and transpose to get dimensions\n    # (batch_size, num_heads, seq_length, head_dim)\n    q = q.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    k = k.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    v = v.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n\n+   # Reshape to (batch_size, seq_length, num_heads, head_dim)\n+   q = q.transpose(2, 3)\n+   v = v.transpose(2, 3)\n    \n+    # Introduce non-linearity\n+    q = F.relu(q)\n+    k = F.relu(k)\n\n+    # Combine scores\n+    scores = torch.matmul(v, k)\n+    x = torch.matmul(scores, q)\n    \n+    # Scale\n+    x = x[:, :, :-1] / (x[:, :, -1:] + 1e-15)\n    \n    # Combine the output from multiple heads\n    x = x.transpose(1, 2).reshape(bsz, seq_length, self.embed_dim)\n    \n    # Final linear projection\n    output = self.out_proj(x)\n    return output\nIt‚Äôs also worth pointing out that SANA uses no positional encodings (so-called NoPE). The SANA authors conjectured that the use of Mix-FFN blocks helped them get away with NoPE without incurring any loss in performance.\n\nThoughts\nThroughout the course of this post, we saw many architectural configurations of the attention mechanism. Some questions that may still arise:\n\nIs there any benefit to using cross-attention for image-video generation at all?\nHow can we compensate for the compute intensity of joint-attention?\nIs the Lumina2 way of doing joint-attention the way to go?\nIs it necessary to do masking in joint-attention? If so, what are the benefits?\n\nIn defense of the widely adopted and optimized vanilla attention, could we interleave quadratic attention and window attention (as done in Gemma2 [15])?\nAll of these questions (and possibly more) warrant a careful ablation study.\nAcknowledgements: Thanks to Aritra Roy Gosthipaty for useful feedback."
  },
  {
    "objectID": "posts/attn-diffusion-2.html#linear-attention",
    "href": "posts/attn-diffusion-2.html#linear-attention",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Linear attention",
    "text": "Linear attention\nAs the world already knows, attention has a quadratic time complexity. This can pose prohibitive challenges when operating with very long sequences despite improved techniques like Flash Attention.\nSANA [2] replaced all vanilla attention with linear attention. More specifically, in each of its transformer blocks, SANA has two kinds of attention:\n\nlinear self-attention for the noisy latents,\nregular cross-attention for the noisy latents (x) and the condition representations (context).\n\nTo facilitate local interactions between the tokens, it used ‚ÄúMix-FFN‚Äù blocks [13], [14].\n\n\n\nLinear attention block and the Mix-FFN block. Figure taken from the SANA paper [2].\n\nImplementation of this linear-attention variant is by far the simplest. We show the main changes introduced when compared to the classic self-attention:\ndef forward(self, x):\n    # x shape: (batch_size, seq_length, embed_dim)\n    bsz, seq_length, _ = x.size()\n    \n    # Compute queries, keys, and values using separate linear layers\n    q = self.to_q(x)  # shape: (batch_size, seq_length, embed_dim)\n    k = self.to_k(x)  # shape: (batch_size, seq_length, embed_dim)\n    v = self.to_v(x)  # shape: (batch_size, seq_length, embed_dim)\n    \n    # Reshape and transpose to get dimensions\n    # (batch_size, num_heads, seq_length, head_dim)\n    q = q.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    k = k.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n    v = v.view(bsz, seq_length, self.num_heads, self.head_dim).transpose(1, 2)\n\n+   # Reshape to (batch_size, seq_length, num_heads, head_dim)\n+   q = q.transpose(2, 3)\n+   v = v.transpose(2, 3)\n    \n+    # Introduce non-linearity\n+    q = F.relu(q)\n+    k = F.relu(k)\n\n+    # Combine scores\n+    scores = torch.matmul(v, k)\n+    x = torch.matmul(scores, q)\n    \n+    # Scale\n+    x = x[:, :, :-1] / (x[:, :, -1:] + 1e-15)\n    \n    # Combine the output from multiple heads\n    x = x.transpose(1, 2).reshape(bsz, seq_length, self.embed_dim)\n    \n    # Final linear projection\n    output = self.out_proj(x)\n    return output\nIt‚Äôs also worth pointing out that SANA uses no positional encodings (so-called NoPE). The SANA authors conjectured that the use of Mix-FFN blocks helped them get away with NoPE without incurring any loss in performance.\n\nThoughts\nThroughout the course of this post, we saw many architectural configurations of the attention mechanism. Some questions that may still arise:\n\nIs there any benefit to using cross-attention for image-video generation at all?\nHow can we compensate for the compute intensity of joint-attention?\nIs the Lumina2 way of doing joint-attention the way to go?\nIs it necessary to do masking in joint-attention? If so, what are the benefits?\n\nIn defense of the widely adopted and optimized vanilla attention, could we interleave quadratic attention and window attention (as done in Gemma2 [15])?\nAll of these questions (and possibly more) warrant a careful ablation study.\nAcknowledgements: Thanks to Aritra Roy Gosthipaty for useful feedback."
  },
  {
    "objectID": "posts/attn-diffusion-2.html#thoughts",
    "href": "posts/attn-diffusion-2.html#thoughts",
    "title": "Flavors of attention in modern diffusion models",
    "section": "Thoughts",
    "text": "Thoughts\nThroughout the course of this post, we saw many architectural configurations of the attention mechanism. Some questions that may still arise:\n\nIs there any benefit to using cross-attention for image-video generation at all?\nHow can we compensate for the compute intensity of joint-attention?\nIs the Lumina2 way of doing joint-attention the way to go?\nIs it necessary to do masking in joint-attention? If so, what are the benefits?\n\nIn defense of the widely adopted and optimized vanilla attention, could we interleave quadratic attention and window attention (as done in Gemma2 [15])?\nAll of these questions (and possibly more) warrant a careful ablation study.\nAcknowledgements: Thanks to Aritra Roy Gosthipaty for useful feedback."
  },
  {
    "objectID": "posts/mlapis-maker.html",
    "href": "posts/mlapis-maker.html",
    "title": "The Maker Philosophy with ML APIs",
    "section": "",
    "text": "In this post, I discuss how I used several Google Cloud Platform (GCP) APIs to turn two ideas into small prototypes. It includes my thought process, the problems I ran into while developing the prototypes, and my approach toward tackling them. All the code discussed in the post is available in this repository.\nAs a Machine Learning (ML) Practitioner, I advocate for having an understanding of the underlying principles of the models and other stuff that I use. This understanding has many extents. Sometimes, it involves minimally implementing models, and sometimes it may not involve the from-scratch implementation. When it does not involve the implementation part and when the model is readily available, I prefer to put such models directly to use and get a sense of their broader capabilities.\nWith libraries like TensorFlow, PyTorch, and Scikit-Learn, realizing this usage has never been easier. As all of these libraries are open-source, you could easily get access to the low-level primitives of their model APIs whenever you‚Äôd like. It may require you to have a sufficient amount of experience with the library you‚Äôd use. But as a Machine Learning Practitioner, one cannot skip this practice. It‚Äôs important to have a good grip over a particular Machine Learning library given the domain of choice (structured tabular dataset, images, texts, audios, for example).\nOn the other hand, APIs that offer ML as a service, allow non-ML folks to incorporate the power of Machine Learning in their applications very easily. This way developers can prototype ideas faster than ever. Some would argue that leaky abstractions can hit sooner than expected and it can be particularly very miserable in Machine Learning. Nonetheless, if you are more on the applied side of things and don‚Äôt want to worry about this aspect, that‚Äôs perfectly fine.\nI wanted to revisit this idea through the lens of an ML Practitioner. More precisely, I wanted to build a series of short demos utilizing the Cloud ML APIs offered by Google Cloud Platform. The premise here is if I have an idea for an ML project, I wanted to see how quickly I can develop a PoC around it.\n\nThe ideation phase\nLet me quote Emil Wallner from this interview -\n\nIt‚Äôs important to collect objective evidence that you can apply machine learning.\n\nWith regard to successful ML practice, this statement couldn‚Äôt have been more appropriate. Machine Learning has affected almost every industry in some way, it has changed the way we develop and perceive software. Coming up with an ML application idea that‚Äôs not already there or implemented is actually pretty hard.\nSo, I ideated the prototypes drawing inspiration from what is already available. For example, Dale and Kaz of Google built this uber-cool demo that lets you transform a PDF into an audiobook. I really wanted to build something similar but in a more minimal capacity ‚Äì something that could solely run on a Colab Notebook.\nI decided to revisit some of the GCP ML APIs that I already knew, Vision, Text-to-Speech APIs, for example. As someone that is already working in the field of Computer Vision, I was inclined to do something that involves it. So here are some initial ideas that came to mind after spending a considerable amount of time with the different API documentation available on GCP:\n\nA pipeline that takes a short video clip, detects the entities present in the video and generates an audio clip dictating detected entity labels. This allowed me to spend some time with GCP‚Äôs Video Intelligence API.\nA pipeline that takes an arXiv paper and generates an audio clip of the paper abstract. This was inspired by the demo that Dale and Kaz had already built.\n\nNote that if you are already experienced with the Vision and Text-to-Speech APIs then these may seem very trivial.\n\n\nThe mental model\nAfter these ideas, I designed a bunch of visual workflows demonstrating the steps required to realize these ideas along with the right tooling. Here‚Äôs an example -\n\nI also like to refer to these workflows as mental models. Additionally, it helps me to figure out the major dependencies and steps that may be required for the work so that I can plan accordingly. I discuss the importance of developing mental models in this blog post.\n(You might have noticed that the above model is a bit different from the first initial idea - I added a logo detection block in there as well.)\nHere is another workflow I developed for the second idea I mentioned above:\n\nThis is slightly different from the initial idea I had. In fact, it does not even incorporate anything related to the Vision API. If I only wanted to deal with arXiv papers, I thought using the arXiv API (I used the arXiv Python library) would be a far more reasonable option here since it already provides important information about an arXiv paper such as its categories, abstract, last updated date, and so on.\nFinally, I wanted to combine the Vision and Text-to-Speech APIs for the second idea I had. In their demos, Dale and Kaz used AutoML Tables to train a model capable of classifying a paragraph of text into the following categories - ‚Äúbody‚Äù, ‚Äúheader‚Äù, ‚Äúcaption‚Äù and ‚Äúothers‚Äù. But I wanted to see if I can bypass this additional training step to filter out the abstract block of a paper and perform optical character recognition (OCR) locally. So, I came up with the following workflow -\n\nAs we can see I am using two Python libraries additionally -\n\npdf2image - as the name suggests, it is for converting a PDF file to PNG.\npytesseract - this is for performing OCR locally on an image.\n\nIn the next sections, I‚Äôll discuss the problems I faced while implementing these workflows in code, and how I went about approaching the solutions.\n\n\nBuilding a short video descriptor\nIn the following texts, we will go over the main ingredients that turned out to be important while developing the prototypes. This will include some code along with the motivation to justify their inclusion.\nFor the first two workflows, it was mostly about reading the documentation carefully and figuring out the right APIs to use. GCP provides first-class documentation for these APIs with bindings available in many different languages as you can see in the figure below -\n\nI repurposed these code snippets for the workflows. The Python binding of the Video Intelligence API is simple to use -\nYou first instantiate the client and instruct what all you are interested in performing -\nvideo_client = videointelligence.VideoIntelligenceServiceClient()\nfeatures = [videointelligence.enums.Feature.LABEL_DETECTION]\nIt provides a bag of different features like entity detection, logo recognition, text recognition, object tracking, and so on. Here I am only interested in performing entity detection on a per-segment basis. A user usually specifies segments if they are interested to only analyze a part of their videos. I didn‚Äôt specify any segments, and in that case, the Video Intelligence API handles the entire video as a segment. The API also allows you to perform label detection on more granular levels, i.e.¬†on both shot and frame levels.\nAfter the initialization, it was only a matter of a few keystrokes till I made my first video annotation request -\n# Specify the mode in which label detection is to be performed\nmode = videointelligence.enums.LabelDetectionMode.SHOT_AND_FRAME_MODE\nconfig = videointelligence.types.LabelDetectionConfig(label_detection_mode=mode)\ncontext = videointelligence.types.VideoContext(label_detection_config=config)\n \n# Make the request\noperation = video_client.annotate_video(\n    input_uri=gcs_path, features=features, video_context=context)\nHere I am supplying a GCS bucket path of the video I wanted to infer on. Processing the results of the operation is also straightforward -\n# Process video/segment level label annotations\n# Get the first response, since we sent only one video.\nsegment_labels = operation.result.annotation_results[0].segment_label_annotations\nvideo_labels = []\nfor (i, segment_label) in enumerate(segment_labels):\n    print(\"Video label description: {}\".format(segment_label.entity.description))\n    video_labels.append(segment_label.entity.description)\nAfter I got the entity labels on the entire video the next task was to use the Text-to-Speech API to generate an audio clip. For that, I simply followed the official tutorial and reused the code.\nThe logo detection pipeline is almost similar with some very minor changes. In case you want to catch all the details please follow this Colab Notebook.\nI tested the entire workflow on the following video and you can see the outputs right below it -\n\nProcessing video for label annotations:\n\nFinished processing.\nVideo label description: sidewalk\nVideo label description: street\nVideo label description: public space\nVideo label description: pedestrian\n\nProcessing video for logo detection:\n\nFinished processing.\nAs for the audio clip, it got came out pretty nice -\n\n\n\nSpeed-wise the entire pipeline executed pretty quickly.\nI had some previous experience working with videos, so I was able to get an idea of what was going under the hood for the video-related activities but for speech, I plan to get to that probably in the next summer (?)\nA potential extension of this demo could be developed to aid blind people to navigate their ways when they are outside. I developed this demo keeping this mind, hence you won‚Äôt see any visual results.\n\n\nDetecting, cropping, and reading an arXiv summary\nI presented with two different workflows for the second idea i.e.¬†get the abstract of an arXiv paper and generate an audio clip of it. The workflow involving the arxiv Python library wasn‚Äôt problematic at all, so I am not going to discuss it in detail. You can always check out this fully worked out Colab Notebook in case you are interested.\nThe other workflow is a bit more involved. In there, I wanted to take an arXiv paper in PDF format, use the Vision API to get blocks of texts from it, and then locate the abstract from there like so -\n\nBut that‚Äôs not it. I also wanted to perform OCR locally on the text blocks. This essentially allowed me to reduce the number of calls to the Vision API and thereby saving me some $. The final piece of the puzzle was to take the local OCR results and generate an audio clip. If you saw the Text-to-Speech documentation, you probably noticed that it is really not a big deal.\nSo, to realize this workflow here‚Äôs what I did (Colab Notebook) -\n\nAs I am only interested in dealing with the abstract of a paper, I first converted the entire PDF-formatted paper to PNG and serialized only the first page. I used the pdf2png library for this.\nNext, I used the Vision API to make a document_text_detection() request for getting the dense text blocks. The code for this is again, very straightforward -\nclient = vision.ImageAnnotatorClient()\nbounds = []\n\nwith io.open(image_file, 'rb') as image_file:\n    content = image_file.read()\n\nimage = types.Image(content=content)\nresponse = client.document_text_detection(image=image)\ndocument = response.full_text_annotation\n\n# Segregate the blocks\nfor page in document.pages:\n    for block in page.blocks:\n        bounds.append(block.bounding_box)\nThen I used the example presented here to draw the bounding boxes on the input image which we saw earlier. I also reused these bounding boxes to segregate different blocks as inferred by the Vision API.\nI am not going to get into the gory details of how I did the segregation. The catch here is for dense text block detection, Vision API returns polygon coordinates and not rectangular coordinates. So, I had to take polygon crops to segregate the different text blocks. (Thanks to this StackOverflow thread.)\nAfter the segregation part, I used pytesseract to perform OCR on the segregated text blocks. In pytesseract it‚Äôs literally doable with text = pytesseract.image_to_string(image_block).\nNow, an abstract cannot be just a single character (if the OCR was performed correctly). So I only considered those OCR‚Äôd texts where the character length is greater than 1000.\nEven with this kind of thresholding, you‚Äôd end up with multiple text blocks where this criterion holds. To counter this, I first sorted the OCR‚Äôd text blocks with respect to their character lengths and checked if a text block contained only one or no reference to citations. If this criterion was matched then the text block is returned as the abstract.\nHere‚Äôs how I coded it up:\ntexts_sorted = sorted(texts, key=len)\nfor text in texts_sorted:\n    if text.split()[0].isupper() & text.count(\"[\") &lt;= 1:\n        abstract = text\nThe upper case criterion is there to ensure an abstract always starts with an uppercase letter.\nI am aware that these handcrafted rules can get broken for many instances. But I wanted to explore this possibility anyway.\nTo make sure the Text-to-Speech API does not account for any citation I filtered out the raw text to escape them - raw_lines = re.sub(\"[[\\s*\\d*\\,*]*]\", \"\", raw_lines).\n\nAnd that‚Äôs it! After a number of trial and error rounds, I was able to get a decent output.\n\n\n\n\n\n\nFinal thoughts\nThroughout this post, we went over two different ideas that are good prototype candidates for Machine Learning. We saw how easy it is to see these ideas in actions with different ML APIs. We saw how to make these different APIs work together to solve a given problem. Now, if you are feeling excited enough, you can dive deeper into the different ML tasks we saw: detection and classification, for example. Also note that even if one is using these APIs, it‚Äôs important to be able to process the API responses properly for the project at hand.\nI would like to leave you with this amazing resource provided by GCP. It includes detailed solution walkthroughs of real-world problem scenarios across a wide range of different industry verticals. They also show how to make the best use of different GCP services.\nI would like to thank Karl Weinmeister for reviewing this post and for sharing his valuable feedback. Also, thanks to the GDE program for providing the GCP credit support which made these demos possible."
  },
  {
    "objectID": "pages/education.html",
    "href": "pages/education.html",
    "title": "Education",
    "section": "",
    "text": "(The formal ones may be)\n\nB.Tech in IT from Netaji Subhash Engineering College (2013 - 17) (Final year dissertation: A CFS‚ÄìDNN-Based Intrusion Detection System)\nHigh School from Jadavpur Vidyapith (PCMC) (2005 - 13)\nCourses/certifications relevant to my subject of interest:\n\nData Scientist with Python Track (DataCamp)\nData Analyst with Python Track (DataCamp)\nDeep Learning Specialization (Coursera)\nAdvanced Machine Learning with TensorFlow on Google Cloud Platform (Coursera)\nTensorFlow in Practice Specialization (Coursera)\nTensorFlow: Data and Deployment Specialization (Coursera)\nGenerative Adversarial Networks (GANs) (Coursera)\nNatural Language Processing (Coursera)\nTensorFlow Developer Certification\nMathematics for Machine Learning (Coursera)\nMachine Learning Engineering for Production (MLOps) (Coursera)\nProfessional Machine Learning Engineer (Google Cloud)"
  },
  {
    "objectID": "pages/interviews.html",
    "href": "pages/interviews.html",
    "title": "Interviews",
    "section": "",
    "text": "The purpose of conducting these interviews is to mainly get insights about the real-world project experiences, perspectives on learning new things, some fun facts and thereby enriching the communities in the process. I sincerely thank the interviewees for taking the time out from their busy schedules and for agreeing to do these interviews. Here are the interviews I have done so far -\n\nAn interview with Robert Crowe, Developer Advocate (TensorFlow) at Google\nAn interview with Snehasis Banerjee, Scientist at TCS Research and Innovation\nAn interview with Abhishek Kumar, Senior Manager, Data Science at Publicis Sapient\nAn interview with Laurence Moroney, Developer Advocate at Google\nAn interview with Karl Fezer, AI Ecosystem Evangelist at Arm\nAn interview with Dan Becker, Team Lead of Kaggle Learn & Product Lead of Kaggle Kernels\nAn interview with Rajarshee Mitra, Data Scientist at Microsoft\nAn interview with Alessio, Lead Data Scientist at FloydHub\nAn interview with Joel Grus, Research Engineer at Allen Institute for Artificial Intelligence\nAn interview with Josh Tobin, Research Scientist at OpenAI\nAn interview with Andrew Ferlitsch, Developer Program Engineer at Google\nAn interview with Shalini De Mello, Principal Research Scientist at NVIDIA\nAn interview with Rahul Agrawal, Principal Machine Learning Manager at AI and Research, Microsoft\nAn interview with Aakash Nain, Research Engineer at Ola\nAn interview with Xander Steenbrugge, Machine Learning Researcher & YouTuber at ‚ÄúArxiv Insights‚Äù\nAn interview with Ines Montani, Co-founder at Explosion\nAn interview with Girish Palshikar, Principal Scientist at TCS Research and Innovation\nAn interview with Christoph Molnar, Interpretable Machine Learning Researcher\nAn interview with Leslie Smith, Senior Research Scientist at U.S. Naval Research Laboratory\nAn interview with Arindam Pal, Senior Research Scientist at CSIRO\nAn interview with Ankur Patel, Vice President of Data Science at 7Park Data\nAn interview with Max Pumperla, Deep Learning Engineer at Skymind\nAn interview with Abhishek Thakur, Data Scientist, and Kaggle 3x Grandmaster\nAn interview with Dmytro Mishkin, Computer Vision Researcher\nAn interview with Ellick Chan, Head of University Relations and Research ‚Äî Intel AI Academy\nAn interview with Thomas Wolf, Chief Science Officer at Hugging Face\nAn interview with Dat Tran, Head of AI at Axel Springer AI\nAn interview with Daniel Seita, Ph.D.¬†student at UC, Berkeley\nAn interview with Vladimir Iglovikov, Senior Computer Vision Engineer at Lyft\nAn interview with Hamel Husain, Staff Machine Learning Engineer at GitHub\nAn interview with Patrick Hall, Principal Scientist at bnh.ai and Advisor to H2O.ai\nAn interview with Colin Raffel, Research Scientist at Google\nAn interview with Niki Parmar, Senior Research Scientist at Google Brain\nAn interview with Alexander (Sasha) Rush, Associate Professor at Cornell University\nAn interview with Vincent Sitzmann, Postdoctoral Researcher at MIT\nAn interview with Dan Hendrycks, Ph.D.¬†student at UC Berkeley\n\nI have had an amazing time interviewing these incredible folks and I am grateful to them. For other competing priorities, I am discontinuing the series for an indefinite period. If you enjoy reading through interviews like these, you might want to check out the Machine Learning Street Talk podcast on YouTube."
  },
  {
    "objectID": "pages/talksseminarsworkshops.html",
    "href": "pages/talksseminarsworkshops.html",
    "title": "Talks/Seminars/Workshops",
    "section": "",
    "text": "I love to attend developer meetups, conferences, workshops and learn from them as much as I can. I sometimes talk on a range of topics that I love the most. All the slides of my talks/sessions can be found below.\n\nGiven by me\n\nPresented our paper A CFS‚ÄìDNN-Based Intrusion Detection System at International Conference on Communication Devices and Networking, Sikkim Manipal Institute of Technology, Sikkim, June 3, 2017.\nPresented our paper A Comparative Study of Different Ensemble Learning Techniques Using Wisconsin Breast Cancer Dataset, at International Conference on Computer, Electrical & Communication Engineering, Techno India University, Kolkata, December 23, 2017.\nCo-presented our paper A Novel Transfer Learning-Based Missing Value Imputation on Discipline Diverse Real Test Datasets‚ÄîA Comparative Study with Different Machine Learning Algorithms at International Conference on Emerging Technologies in Data Mining and Information Security, University of Engineering and Management, Kolkata, February 23, 2018.\nSpoke on Cyclical Learning Rates for training Neural Nets at DevFest Kolkata, November 3, 2018.\nConducted a hack-session on Cyclical Learning Rates at DataHack Summit (organized by Analytics Vidhya), Bangalore, November 23, 2018.\nDelivered talks on Introduction to BigQuery at GDG Kolkata Cloud Study Jam (Academy of Technology), Google Cloud Next ‚Äô19 Extended - Kolkata on April 12 and April 19, 2019 respectively.\nConducted a session on Ten Updates Introduced in TensorFlow 2.0 along with a short quiz at Google I/O Extended 2019, Kolkata, May 11, 2019.\nConducted a session on Training neural nets: A methodical approach at ML/AR Developer Day organized by GDG Kolkata and DSC HIT (May 30, 2019).\n\nConducted the same session but in a more detailed manner at ML With The Experts - GDG Kolkata Meetup (July 7, 2019).\n\nSpoke at Google I/O Extended 2019, Bhubaneswar on Ten Updates Introduced in TensorFlow 2.0, June 9, 2019. Also shared a few opportunities with the students (link to the Opportunities‚Äô deck).\nSpoke at DevFest Kolkata 2019 about how to approach the process of model deployment, August 3, 2019_._ My talk was titled Connecting Flutter with TensorFlow 2.0. Link to the slides, video and the GitHub repository.\nSpoke at DevFest Jaipur 2019 (September 08, 2019) on Structuring Machine Learning Projects.\n\nRemotely presented on this topic at DevFest Izmir 2019 (November 23, 2019). Here‚Äôs the modified deck. Here‚Äôs a recording of the session.\n\nSpoke at Explore ML Academy on Problem Framing and How to find data set and fairness practices, September 14, 2019, Hyderabad.\nSpoke at DevFest Bhubaneswar 2019 (September 22, 2019) on The Human Loop in Machine Learning.\nSpoke at DevFest Goa 2019 (September 29, 2019) on Training Neural Nets: a Hacker‚Äôs Perspective.\n\nSpoke at Class III of Launchpad Accelerator India (October 16, 2019), Bangalore on an extended version of the same topic. Deck: http://bit.ly/LPA_3.\nRemotely presented on this topic at DevFest Warsaw & Radzymin 2019 (December 7, 2019).\n\nPresented my work on Blood Cell Detection using TensorFlow Object Detection API at TensorFlow Roadshow, Bangalore (October 01, 2019). Deck: http://bit.ly/tf-roadshow-sayak.\nRemotely presented my work on Predicting Publisher‚Äôs Names from Hackernews Article Titles at Global GDE Summit (October 26, 2019). Video available here (Courtesy: Akshay Bahadur). Deck: http://bit.ly/GDESummit19.\nRemotely presented at Machine Learning Weekend, Turkey on Building data pipelines with tf.data (November 3, 2019).\nPresented at Kaggle Days Mumbai on On the learning dynamics of neural nets (November 30, 2019).\nConducted a workshop on Applied Deep Learning using TensorFlow 2.0 and GCP (includes topics like data pipeline optimization, cyclical learning rates, mixed-precision training and so on) at Launchpad India Accelerator Bootcamp (December 12 - 13, 2019). Content available here: http://bit.ly/mlb-code-sayak.\nSpoke at DevLoop on Your first machine learning project, Ganpat University, Gujrat, India (January 04, 2020). Deck: http://bit.ly/dloop20. I have spoken about this topic at multiple occasions. A session recording is available here.\nSpoke at Improving machine learning model on Weights and Biases for better machine learning, Bangalore (February 08, 2020). Deck: http://bit.ly/blr-wb.\nSpoke at Sigma 2020 on Machine Learning: For the Community by the Community, Kolkata (February 12, 2020).\nSpoke at MENA Digital Days 2020 on Building data pipelines with tf.data. Deck here, session video here.\nSpoke for GDG Goa at an online event on Hello, TensorFlow. Deck here, session here.\nSpoke for GDG Pune and WTM Pune on Doing more with TensorFlow Lite, April 26, 2020. A session recording is available here (it was for the Deep Learning Salon hosted by Weights and Biases).\nSpoke for Global AI Hub, Turkey on Gotchas of Transfer Learning for Image Classification, May 01, 2020. A recording of the session is available here.\nSpoke on TensorFlow Hub: Models, Models, and Models for TFUG Hyderabad on May 03, 2020. Deck: http://bit.ly/tf-hub. A recording of the session is available here.\nParticipated in an ML fire-side chat hosted by Aniedi to speak to the developers of African regions. Recording is available here (May 30, 2020).\nSpoke at Pie and AI Kolkata on Becoming One with the Data. Deck here & session recording here (May 31, 2020).\nSpoke on Model Optimization 101 for TFUG Thrissur. Deck here (June 07, 2020). A recording on the same topic from a different event is available here. I have also presented this at Google for Startups Accelerator India (GoogleDevsIN tweet). A recording of that session is available here.\nSpoke on A few good stuff in TensorFlow Lite for GDG Berlin (July 16, 2020). Deck is available here and a recording is available here.\nSpoke on GitHub Actions for Machine Learning at Global AI On Tour Mumbai (September 27, 2020). Deck is available here.\nSpoke on The Maker Philosophy with ML APIs at Mindhack Summit (October 12, 2020). Deck is available here.\nSpoke on Adversarial Examples in Deep Learning at DevFest UK & Ireland 2020 (October 17, 2020). Deck is available here.\nTook a workshop on Adversarial Robustness in Deep Learning with Dipanjan Sarkar at Deep Learning DevCon 2020 (October 29, 2020). The materials are available here - bit.ly/adv_learn. We presented this at Kshitij 2021 as well and here‚Äôs the recording.\nSpoke on Demystifying Self-Supervised Learning for Visual Recognition at SciPy Japan 2020 (October 30, 2020). Deck is available here - bit.ly/scipy-sp. Session recording is available here.\nSpoke to Santosh on Demystifying ML and AI for beginners at his podcast Tech Talks With Santosh: https://youtu.be/BhLQN-XIO04 (November 07, 2020).\nSpoke on Key Trends of Computer Vision 2021 (June 09, 2021). Deck is available here. A session recording is available here. A blog post summarizing the content (by Benedict Neo) is available here. I have also presented this at Takshak‚Äô21, Techfest of ISM Dhanbad.\nVertex AI for Easier Model Deployments at Google for Startups Accelerator Class 5 (August 28, 2021). Deck is available here. A recording is available here.\nEnabling Possibilities with Open-Source in Machine Learning at DevFest India 2021 (October 24, 2021). My deck is available here. A recording is available here.\nCitizen Scientists Tackling Devastating Floods and Disaster Relief with Semi-supervised Deep Learning at NVIDIA GTC 2021 (November 09, 2021). This is based on our work on using semi-supervision for segmenting flood regions. This work was also presented as a poster at PyTorch Developer Day and the PyTorch team helped us create a beautiful poster for that.\nImproving Dataflow pipelines for text data at scale (with Nilabhra Roy Chowdhury) at Innovators Hive from Google Cloud (March 30, 2022). We also presented this at the Beam Summit 2022. Slide deck is available here. A video presentation is available here.\nBuilding a Mobile-optimized Image Recognition Model at DevFest Bangalore 2022 (September 18, 2022). Slides are here. A recording is here.\nFantastic ML Deployments & How to do them with Vertex AI at Cloud Community Days Ahmedabad 2022 (September 24, 2022). Slides are here.\nBetter Hardware Provisioning for ML Experiments on GCP at Cloud Next 2022 (October 13, 2022). All the materials are here. A video recording is available here.\nBeing a Maker with ML APIs at DevFest Jalandhar 2022 (October 16, 2022). All the materials are here.\nAnatomy of Capstone ML Projects at DevFest Nagpur 2022 (November 5, 2022). Slides are here. Presented this at DevFest Tashkent 2022 as well.\nImproving as an ML Practitioner at DevFest Kolkata 2022 (November 13, 2022). Slides are here. Presented this at DevFest Indore 2022 as well.\nBringing ML Models to Life with Hugging Face Spaces at DevFest Gandhinagar 2022 (November 21, 2022).\nML Problems: Formulation and Adoption at Google Developers Startup Bootcamp (University Edition); Gurugram, India (December 06, 2022). Tweet by GoogleDevsIN. Deck is here.\nYou Don‚Äôt Know TensorFlow at TFUG Kolkata (March 19, 2023). Materials are here. A recording of the talk can be found here.\nOpen and Collaborative MLOps, invited lecture at HKUST (March 31, 2023). My slides are here.\nBuilding DALL-E 2 like Systems in Minutes at NIT Silchar (April 8, 2023). Presented on the same topic at IIT Guwahati (April 22, 2023). Slides are here.\nDemocratizing Generative Models with üß® diffusers at the NVIDIA-HF meetup (April 29, 2023) (with Suraj Patil). Slides are here. Here‚Äôs another version of the presentation that I presented at the DataHack Summit 2023.\nShip Faster TensorFlow Models with XLA at Google Cloud Community Days, Kolkata (May 7, 2023). Slides are here.\n\nGenerating Photorealistic Images using AI with Diffusers in Python at DataCamp (May 16, 2023). Materials are here. A recording of the session is here.\nMaking Keras Models go brrr with XLA at Keras Community Day Kolkata, August 27, 2023. Slides are here. I have given the same talk at Keras Community Day Chandigarh too (September 02, 2023).\nEnd-to-End Pipeline for Segmentation with TFX, GCP, & ü§ó (with Chansung Park), ML Community Summit 2023 (November 23, 2023). Slides are here.\nStaying relevant as an MLE in the age of GenAI, DevFest Kolkata 2023 (December 22, 2023). Slides are here.\nBuilding a Personal Coding Assistant (with Sourab Mangrulkar), Build with AI, Bangalore (March 02, 2024). Slides are here.\nML Careers in 2024, IIT Indore (April 11, 2024). Slides are here.\nState-of-the-art image generation üß® with Diffusers, EuroPython, Prague (July 10, 2024). Slides and recording are here.\nLLaMADuo: Marrying small language models with larger ones, GCCD Kolkata, India (August 17, 2024). Slides are here.\nDemocratizing Diffusion Models with Diffusers, Open-Source Summit, Japan (October 28, 2024). Slides are here. Recording is here.\nCrafting pixels in the wild with Flux üß®, Practical GenAI: Image and Diffusion Models, Google Bangalore, India (January 25, 2025). Slides are here.\n\nFor more research-oriented talks, refer here.\n\n\nPodcasts where I have appeared\n\nMachine Learning Street Talk. Spoke to Tim Scarfe, Connor Shorten, and Yannic Kilcher.\nAppeared on a podcast discussing my ML journey and other related things: Hugging Face‚Äôs ML Revolution.\nPeople of AI podcast (Google), spoke to Ashley Oldacre and Luiz Gustavo Martins from Google. Episode recording is here.\nAppeared on the Overpowered podcast with Varun Mayya. Find it here.\nSoftware Engineering Daily, spoke to Sean Falconer. Podcast recording is here.\nAppeared on the Humans of Digital podcast by CI&T. Find it here.\nAppeared on the College Street Kolkata podcast. Find it here.\n\n\n\nML Street Talk\nI used to appear on one of the most popular podcasts in machine learning called the ML Street Talk. Below are the episodes where I have made appearances.\n\nSpoke to Mathilde Caron (Research Assistant at Facebook AI), with Ayush Thakur, Tim Scarfe, and Yannic Kilcher.\nSpoke to Sara Hooker (Google Brain), with Tim Scarfe, and Yannic Kilcher.\nSpoke to Sanyam Bhutani (H2O.ai), with Tim Scarfe, Yannic Kilcher, and Alex Stenlake.\nSpoke to Simon Kornblith (Google Brain) with Tim Scarfe and Yannic Kilcher.\nSpoke to Lena Voita (University of Edinburgh and University of Amsterdam) with Tim Scarfe and Yannic Kilcher.\nSpoke to Hadi Salman (MIT) with Tim Scarfe and Yannic Kilcher.\nSpoke to Ishan Misra (Facebook AI Research) with Tim Scarfe and Yannic Kilcher.\n\n\n\nCo-organized by me\n\nDevFest Kolkata, August 3, 2019.\nTensorFlow All-Around Kolkata, August 31, 2019.\nLet‚Äôs Build, January 4, 2020.\nKolkata Kreate, February 29, 2020.\nTFUG India Summit, September 3 - 6, 2020.\nGenerative AI Meet-up in collaboration with NVIDIA, April 29, 2023.\nJAX/Diffusers Sprint, March 29 - May 08, 2023.\nDeploying Generative AI Models in collaboration with Inferless and Sequoia Capital, June 10, 2023.\n\nNote: If you are interested to invite me as a speaker for your event, please get in touch by dropping an email at spsayakpaul@gmail.com. If you are interested in having me submit a CFP first, that is absolutely fine! Please don‚Äôt hesitate to ask that."
  },
  {
    "objectID": "pages/resources.html",
    "href": "pages/resources.html",
    "title": "Resources",
    "section": "",
    "text": "This page enlists the talks I have given, the podcasts I have appeared on and co-hosted, and other misc things.\n\nTalks / podcasts / events\nMentorship / Awards / Etc.\nInterviews\nA bit about my formal education"
  }
]